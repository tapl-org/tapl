($x:Int. x) 20
($x. x): Int->Int y:Int

check = $funcType.$argType. 

((\x. x) y): check Int->Int Int
((\x. x) y): Int
 

 id = \X. \x:X. x

 id: * -> X -> X
 id: \X. X -> X

 idNat = id Nat
 = (\X. \x:X. x) Nat
 = \x:Nat. x
 idNat: Nat -> Nat

((\X. \x:X. x):(\X. X -> X))
(\X. (\x:X.x): X->X)

id = (\X. \x:X.x): (\X. X->X)

id Nat
= (\X. \x:X.x): (\X. X->X) Nat
[X -> Nat](\x:X. x): [X->Nat](X->X)
\x:Nat. x : Nat->Nat


id = (\x: Nat. x): Nat -> Nat
id 20
((\x: Nat. x): Nat -> Nat) 20
[x->20](\x:Nat. x):[x->20](\x:Nat. Nat)
20: Nat

id = (\x: Nat.x)
= (\x:Nat.x:Nat)
= (\x.x):(\x:Nat.Nat)

id 20
((\x.x):(\x:Nat.Nat)) 20
[x->20](\x.x):(\x:Nat.Nat) 20


\x=Nat.Nat

id = \x:Nat.x
id:typeof(id)
id:\x=Nat.x
id:\x=Nat.Nat
=(\x:Nat.x):(\x=Nat.Nat)

id 20
=((\x:Nat.x):(\x=Nat.Nat)) 20:Nat
=[x->20]x:


id = \x:Nat.x
=(\x:Nat.x:Nat):(\x.Nat)

id 20
=((\x:Nat.x:Nat):(\x.Nat)) 20
=[x->20](x:Nat):[x->20](Nat)
=(20:Nat):Nat
=

id = \x:Nat.x
=(\x.x):(\x=Nat.Nat)

id 20
((\x.x):(\x=Nat.Nat)) 20
((\x.x):(\x.x)) 20:Nat
[x->20]x:[x->Nat]x
20:Nat

((\x.x):(\x=Nat.Nat)) 20:Nat
[x->20]x:[Nat=Nat]Nat
[x->20]x:Nat
20:Nat

((x\.x):(x=Nat.Nat)) 20:Nat
[x\20]x:[Nat=Nat]Nat
[x\20]x:Nat
20:Nat


id = \X. \x:X. x
=\X. \x:X. x:X
=\X. (\x. x):(=X. X)
=(\X. (\x. x)):(=*. (=X. X))

id Nat:*
=(\X. (\x. x)):(=*. (=X. X)) Nat:*
=[Nat\X](\x. x):[*=*](=X. X)
=(\x. x): (=X. X)

id = \X:*. \x:X. x
=\X:*. \x:X. x:X
=\X:*. (\x. x):(\x=X. X)
=(\X. (\x. x)):(\X=*. (\x=X. X))
=\X.\x.x:\X=*.\x=X.X

id Nat:*
= (\X.\x.x:\X=*.\x=X.X) Nat:*
= (\X.\x.x) Nat:* : (\X=*.\x=X.X) Nat:*
= (\X.\x.x) Nat:* : [X->Nat,*=*](\x=X.X)
= (\X.\x.x) Nat:* : (\x=Nat.Nat)
= [X->Nat](\X.\x.x) : (\x=Nat.Nat)
= \x.x : \x=Nat.Nat

(\x.x : \x=Nat.Nat) 20:Nat
= ((\x.x) 20:Nat) : (\x=Nat.Nat) 20:Nat
= [x->20] x : [x->20,Nat=Nat] Nat
= 20 : Nat


id=\X:*.\x:X.x
=\X:*.\x:X.x:X
=\X:*.(\x.x):(\x:X.X)
=(\X.(\x.x)):(\X:*.(\x:X.X))
=\X.\x.x:(\X:*.\x:X.X)

id Nat:*
=(\X.\x.x:(\X:*.\x:X.X)) Nat:*
=((\X.\x.x) Nat):((\X:*.\x:X.X) Nat:*)
=((\X.\x.x) Nat):((\X:*.\x:X.X) Nat:*)
=((\X.\x.x) Nat):((\X.\x:X.X) Nat)
=((\X.\x.x) Nat):([X->Nat](\x:X.X))
=((\X.\x.x) Nat):(\x:Nat.Nat)
=(\x.x):(\x:Nat.Nat)

(\x.x):(\x:Nat.Nat) 20:Nat
=((\x.x) 20):((\x:Nat.Nat) 20:Nat)
=((\x.x) 20):((\x.Nat) 20)
=((\x.x) 20):Nat
=20:Nat


def pair=\a.\b.\f.((f a) b)

def List = \n:Nat. []:<List,n>
=(\n. []):(\n:Nat. <List,n>)

def nil = []:<List,0>
def cons = \n:Nat.\a:<List,n>.\e:Nat. (append a e):<List, + n 1>
= \n:Nat.\a:<List,n>.(\e. append a e):(\e:Nat. <List, + n 1>)
= \n:Nat.(\a.\e. append a e):(\a:<List,n>.(\e:Nat. <List, + n 1>))
= (\n.\a.\e. append a e):(\n:Nat.\a:<List,n>.\e:Nat. <List, + n 1>)

cons 0 nil 1
= (\n.\a.\e. append a e):(\n:Nat.\a:<List,n>.\e:Nat. <List, + n 1>) 0:Nat
= ((\n.\a.\e. append a e) 0):((\n:Nat.\a:<List,n>.\e:Nat. <List, + n 1>) 0:Nat)
= ((\n.\a.\e. append a e) 0):((\n.\a:<List,n>.\e:Nat. <List, + n 1>) 0)
= ((\n.\a.\e. append a e) 0):([n->0](\a:<List,n>.\e:Nat. <List, + n 1>) 0)
= ((\n.\a.\e. append a e) 0):(\a:<List,0>.\e:Nat. <List, + 0 1>)
= ((\n.\a.\e. append a e) 0):(\a:<List,0>.\e:Nat. <List, 1>)
= (\a.\e. append a e):(\a:<List,0>.\e:Nat. <List, 1>)

(\a.\e. append a e):(\a:<List,0>.\e:Nat. <List, 1>) []:<List,0>
=((\a.\e. append a e) []):((\a:<List,0>.\e:Nat. <List, 1>) []:<List,0>)
=((\a.\e. append a e) []):((\a.\e:Nat. <List, 1>) [])
=((\a.\e. append a e) []):(\e:Nat. <List, 1>)
=(\a.\e. append [] e):(\e:Nat. <List, 1>)

(\e. append [] e):(\e:Nat. <List, 1>) 3:Nat
=((\e. append [] e) 3): ((\e:Nat. <List, 1>) 3:Nat)
=((\e. append [] e) 3): ((\e. <List, 1>) 3)
=((\e. append [] e) 3): <List, 1>
=((\e. append [] e) 3): <List, 1>
=(append [] 3): <List, 1>
=[3]: <List, 1>


double = \X:*.\f:X→X.\a:X. f (f a)
Normalize double
=\X:*.\f:X→X.\a:X. f (f a)
=\X:*.\f:X→X.\a:X. f:X→X (f:X→X a:X)
=\X:*.\f:X→X.\a:X. f:X→X (f a):X
=\X:*.\f:X→X.\a:X. (f (f a)):X
=\X:*.\f:X→X.(\a. f (f a)):(\a:X.X)
=\X:*.(\f.\a. f (f a)):(\f:(\x:*.x).\a:X.X)
=(\X.(\f.\a. f (f a))):(\X:*.(\f:(\x:*.x).\a:X.X))
=(\X.\f.\a. f (f a)):(\X:*.\f:(\x:*.x).\a:X.X)



f:X→X a:X
=f:(\X:*.X) X
= (f a):((\X:*.X) X)
= (f a):((\X:*.X) X:*)
= (f a):((\X.X) X)
= (f a):X

f:(\x:*.x) (f a):X
= (f (f a)):((\x:*.x) X)
= (f (f a)):((\x:*.x) X:*)
= (f (f a)):((\x.x) X)
= (f (f a)):X

double Nat
=(\X.\f.\a. f (f a)):(\X:*.\f:(\x:*.x).\a:X.X) Nat
=(\X.\f.\a. f (f a)):(\X:*.\f:(\x:*.x).\a:X.X) Nat:*
=((\X.\f.\a. f (f a)) Nat):((\X:*.\f:(\x:*.x).\a:X.X) Nat:*)
=((\X.\f.\a. f (f a)) Nat):((\X.\f:(\x:*.x).\a:X.X) Nat)
=((\X.\f.\a. f (f a)) Nat):(\f:(\x:*.x).\a:Nat.Nat)

double = \X:*.\f:(x:X.X).\a:X. f (f a)
=\X:*.\f:(x:X.X).\a:X. (f (f a)):X
=\X:*.\f:(x:X.X).(\a.f (f a)):(\a:X. X)
=\X:*.(\f.\a.f (f a)):(\f:(\x:X.X).\a:X. X)
=(\X.\f.\a.f (f a)):(\X:*.\f:(\x:X.X).\a:X.X)

double Nat
=(\X.\f.\a.f (f a)):(\X:*.\f:(\x:X.X).\a:X.X) Nat:*
=((\X.\f.\a.f (f a)) Nat):((\X:*.\f:(\x:X.X).\a:X.X) Nat:*)
=((\X.\f.\a.f (f a)) Nat):((\X.\f:(\x:X.X).\a:X.X) Nat)
=(\f.\a.f (f a)):(\f:(\x:Nat.Nat).\a:Nat.Nat)

inc: (\x:Nat.Nat)


double Nat inc
=(\f.\a.f (f a)):(\f:(\x:Nat.Nat).\a:Nat.Nat) inc:(\x:Nat.Nat)
=((\f.\a.f (f a)) inc):((\f:(\x:Nat.Nat).\a:Nat.Nat) inc:(\x:Nat.Nat))
=((\f.\a.f (f a)) inc):((\f.\a:Nat.Nat) inc)
=((\f.\a.f (f a)) inc):(\a:Nat.Nat)
=(\a.inc (inc a)):(\a:Nat.Nat)

doulbe Nat inc 20:Nat
=(\a.inc (inc a)):(\a:Nat.Nat) 20:Nat
=((\a.inc (inc a)) 20):((\a:Nat.Nat) 20:Nat)
=((\a.inc (inc a)) 20):((\a.Nat) 20)
=((\a.inc (inc a)) 20):Nat
=(inc (inc 20)):Nat
=(inc 21):Nat
=22:Nat


------------

double = \X:*. \f:(\x:X.X). \a:X. f (f a)


id = \X:*.\x:X.x
=(\X.\x.x):(\X:*.\x:X.X)


def Nat:*

def idNat = \x:Nat.x
=\x:Nat.x:Nat


idNat 20:Nat
=(\x:Nat.x:Nat) 20:Nat
=20:Nat

id = \X:*.\x:X.x
=\X:*.\x:X.x:X

id Nat:*
=(\X:*.\x:X.x:X) Nat:*
=\x:Nat.x:Nat


double = \X:*.\f:(\y:X.X).\a:X. f (f a)
=\X:*.\f:(\y:X.X).\a:X. f:(\y:X.X) (f:(\y:X.X) a:X)
=\X:*.\f:(\y:X.X).\a:X. f:(\y:X.X) (f:(\y:X.X) a:X):((\y:X.X) a:X)
=\X:*.\f:(\y:X.X).\a:X. f:(\y:X.X) (f:(\y:X.X) a:X):X
=\X:*.\f:(\y:X.X).\a:X. (f:(\y:X.X) (f:(\y:X.X) a:X):X):X 


double Nat:*
=(\X:*.\f:(\y:X.X).\a:X. (f:(\y:X.X) (f:(\y:X.X) a:X):X):X) Nat:*
=\f:(\y:Nat.Nat).\a:Nat. (f:(\y:Nat.Nat) (f:(\y:Nat.Nat) a:Nat):Nat):Nat

inc:(\x:Nat.Nat)

double Nat inc
=(\f:(\y:Nat.Nat).\a:Nat. (f:(\y:Nat.Nat) (f:(\y:Nat.Nat) a:Nat):Nat):Nat) inc:(\x:Nat.Nat)
=[f -> (\x:Nat. succ x)](\a:Nat. (f:(\y:Nat.Nat) (f:(\y:Nat.Nat) a:Nat):Nat):Nat)
=(\a:Nat. ((\x:Nat. succ x):(\y:Nat.Nat) ((\x:Nat. succ x):(\y:Nat.Nat) a:Nat):Nat):Nat)
=(\a:Nat. ((\x:Nat. succ x):(\y:Nat.Nat) (succ a)):Nat):Nat)

doulbeD = \f:(\y:d.d:*).\a:d. (f (f a)):d

inc=\y:d.y:d
=(\y.y):(\y:d.d)

doubleD inc
=(\f:(\y:d.d).\a:d. (f (f a)):d) inc
=

\x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):Nat->Nat

id=\x:Nat.x
=\x:Nat.x:Nat
=\x:Nat.x:Nat:*

id 20:Nat:*
=(\x:Nat:*.x:Nat:*) 20:Nat:*
=[x->20]x:Nat:*
=20:Nat:*

=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):Nat->Nat
=(\x:Nat.x:Nat):Nat->Nat:*

=\x:Nat. newList:(\x:Nat.List[x:Nat]) x:Nat
=\x:Nat. (newList:(\x:Nat.List[x:Nat]) x:Nat):((\x:Nat.List[x:Nat]) x:Nat)
=\x:Nat. (newList:(\x:Nat.List[x:Nat]) x:Nat):List[x:Nat]
=(\x:Nat. (newList:(\x:Nat.List[x:Nat]) x:Nat):List[x:Nat]):(\x:Nat.List[x:Nat])
=(\x:Nat. (newList:(\x:Nat.List[x:Nat]) x:Nat):List[x:Nat]):(\x:Nat.List[x:Nat]:*)
  :(\x:Nat.*)
  :(Nat:*)->*:*


=λY. λZ. ∀X. (Y→Z→X) → X
=λY. λZ. ∀X. (Y→Z→X) → X


pairNat = λn1:CNat. λn2:CNat. λX. λf:CNat→CNat→X. f n1 n2;
fstNat = λp:PairNat. p [CNat] (λn1:CNat. λn2:CNat. n1); 
sndNat = λp:PairNat. p [CNat] (λn1:CNat. λn2:CNat. n2);

CBool = ∀X.X→X→X;
tru = λX. λt:X. λf:X. t;
fls = λX. λt:X. λf:X. f;

tru = \X. \t:X. \f:X. t
=\X:*.\t:X.\f:X.t
=\X:*.\t:X.\f:X.t:X
=\X:*.\t:X.(\f:X.t:X):(\f:X.X)
=\X:*.(\t:X.(\f:X.t:X):(\f:X.X)):(\t:X.\f:X.X)
=(\X:*.(\t:X.(\f:X.t:X):(\f:X.X)):(\t:X.\f:X.X)):(\X:*.\t:X.\f:X.X)

(\X:*.\t:X.\f:X.X)
=(\X:*.X→X→X) == ∀X.X→X→X

Universal type
id = λX. λx:X. x;
=\X:*.\x:X.x:X
=\X:*.(\x:X.x:X):(\x:X.X:*)
=(\X:*.(\x:X.x:X):(\x:X.X:*)):(\X:*.\x:X.X:*)

=(\X:*.\x:X.X:*)

(\X.\x:X.x:X):(\X.X->X)
(\X.\x:X.x:X):(∀X.X→X)


List=\a:Nat.[0*a]:'List_$a'

List 2
=(\a:Nat.[0*a]:'List_$a') 2:Nat
=[0,0]:'List_2'

id = \x:Nat.x


id 2:Nat
=\x:Nat.x 2:Nat
=\x:Nat.x:Nat 2:Nat
=2:Nat

id=\X.\x:X.x

id Nat 2:Nat
=(\X:*.\x:X.x) Nat 2:Nat
=(\X:*.\x:X.x:X) Nat:* 2:Nat
=(\X:*.\x:X.x:X) Nat:* 2:Nat


=(\X:*.\x:X.x:X)
=(\X:*.(\x:X.x:X):(\x:X.X))
=(\X:*.(\x:X.x:X):(\x:X.X)):(\X:*.(\x:X.X))

=\x:Nat.x:Nat
=(\x:Nat.x:Nat):Nat->Nat

id = \x:Nat.x
=\x:Nat.x:Nat

id 2:Nat
=(\x:Nat.x:Nat) 2:Nat
=((\x:Nat.x:Nat)!2):((\x:Nat.Nat) 2:Nat)
=((\x:Nat.x:Nat)!2):((\x:Nat.Nat) 2:Nat)


4:Nat

(add1:(\x:Nat.Nat) 4:Nat):Nat
=(5:Nat):Nat
=5:Nat

id=\X:*.\x:X.x
=\X:*.\x:X.x:X
=(\X:*.(\x:X.x:X):(\x:X.X))
=(\X:*.(\x:X.x:X):(\x:X.X)):(\X:*.\x:X.X)

id = \x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):(\x:Nat.Nat:*)
=(\x:Nat.x:Nat):(\x:Nat.Nat:*):*


id 2:Nat:*
=(\x:Nat:*.x:Nat:*):(\x:Nat:*.Nat:*):* 2:Nat:*
=((\x:Nat:*.x:Nat:*)!2):((\x:Nat:*.Nat:*):* 2:Nat:*)
=((\x:Nat:*.x:Nat:*)!2):((\x:Nat:*.Nat:*):* 2:Nat:*)
=((\x:Nat:*.x:Nat:*)!2):((\x:Nat:*.Nat:*)!2):(* 2:Nat:*)   error
=((\x:Nat:*.x:Nat:*)!2):((\x:Nat:*.Nat:*)!2):*
=((\x:Nat:*.x:Nat:*)!2):(Nat:*):*
=((\x:Nat:*.x:Nat:*)!2):Nat:*
=((\x:Nat:*.x:Nat:*)!2):Nat:*
=(2:Nat:*):Nat:*
=2:Nat:*

id = \x:Nat.x
=\x:Nat:*.x:Nat:*
=(\x:Nat:*.x:Nat:*):(\x:Nat:*.Nat:*)
=(\x:Nat:*.x:Nat:*):(Nat:*->Nat:*)
=(\x:Nat:*.x:Nat:*):(Nat:*->Nat:*):*

id 2:Nat:*
=(\x:Nat:*.x:Nat:*):(Nat:*->Nat:*):* 2:Nat:*
=((\x:Nat:*.x:Nat:*)!2):((Nat:*->Nat:*):* 2:Nat:*)


id = \x:Nat.x

id 2:Nat
=(id 2:Nat):t[id 2:Nat]
=(id 2:Nat):t[id 2:Nat]

t[id 2:Nat]
=t[id] 2:Nat
=t[\x:Nat.x] 2:Nat
=\x:Nat.t[x] 2:Nat
=\x:Nat.Nat 2:Nat

=(id 2:Nat):(\x:Nat.Nat 2:Nat)
=(id 2:Nat): (Nat->Nat 2:Nat)

id = \x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)

id 2:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat
=((\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat):((\x:Nat.Nat) 2:Nat)

t
eval(t)
=t:typeof(t)
if typeof(t) is binary or type-of-function
  eval(t)
else:
  eval(typeof(t))


(\x:A.y:B) z:C
=((\x:A.y:B) z:C):(A=C->B)

(\x:Nat.x:Nat) 2:A
=((\x:Nat.x:Nat) 2:A):((\x:Nat.Nat) 2:A)
=((\x:Nat.x:Nat) 2:A):((\Nat<=?.Nat) A)
=((\x:Nat.x:Nat) 2:A):

t:(\x:A.b) z:C
if A == C: beta-reduction -> [x->z]b
elif A != C: raise type-error
else: type-it -> (t:(\x:A.b) z:C):((\x:A.b) z:C)

(\a:A.b:B) c:C
if A==C:
  beta-reduction -> [a->c]b:B
elif A!=C:
  raise type-error
elif a not in FV(B):
  ((\a:A.b:B) c:C):A=C->B
else:
  stuck

\x:Nat.x:Nat 2:Nat
2:Nat

\X:*.\x:X.x:X Nat:* 2:Nat
=\x:Nat.x:Nat 2:Nat
=2:Nat


(\a:A.b:B) c:C
=((\a:A.b:B) c:C):((\x:Unit.(\x:A.B) c:C) (equiv A C))

Operators
=[T1,T2, t]  equivalent
$[t]      evaluation (unprotected call)
@[t]      typeof
%[t]      erasure


$[(\a:A.b:B) c:C]
> [a->c]b:B

@[(\a:A.b:B) c:C]
> (\a:A.B) c:C
> if a not in b:B then: =[A,C, B]
> else: =[A,C, $[(\a:A.B) c:C]]


((\a:A.b:B) c:C):(=[A,C, $[(\a:A.B) c:C]])


@[(\x:Nat.x:Nat) 2:Nat]
> =[Nat, Nat, $[(\x:Nat.Nat) 2:Nat]]
> =[Nat, Nat, Nat]
> Nat

$[(\a:A.b:B) c:C]:@[(\x:Nat.x:Nat) 2:Nat]
> $[(\a:A.b:B) c:C]:Nat
> [a->c]b:B:Nat


(\x:Nat.x) 2:Nat

eval[(\x:Nat.x) 2:Nat]:typeof[(\x:Nat.x) 2:Nat]


typeof[(\x:Nat.x) 2:Nat]
> (\x:Nat.Nat) 2:Nat


(\a:A.b:B) c:C

typeof[(\a:A.b:B) c:C]
> typeof[(\a:A.b:B)] c:C
> (\a:A.typeof(b:B)) c:C
> (\a:A.B) c:C

((\a:A.b:B) c:C):(if (= A C) ((\a:A.B) c:C) error)
((\a:A.b:B) c:C):M[A, C, ((\a:A.B) c:C)]

typeof(\x:Nat.x)
\x:Nat.typeof(x)
\x:Nat.Nat

typeof(id 2:Nat)
typecheck(typeof(id) 2:Nat)
\x:Nat.Nat 2:Nat
Nat

id = \x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)

id 2:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat
=((\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat):((\x:Nat.Nat) 2:Nat)
=((\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat):(TRW [Nat Nat Nat])
=((\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat):Nat


eval(id 2:Nat)
=eval(\x:Nat.x 2:Nat)
=2

typeof(id 2:Nat)
=eval(typeof(id) 2:Nat)
=eval(\x:Nat.Nat 2:Nat)
=Nat

\x:A.t:T

     x in FV(t)      x in FV(T)
#A       false           false          closed value: For example: function type A->t
#B       false           true           dependent type
#C       true            false          function
#D       true            true           dependent type & function

id = \x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):(\x:Nat.Nat:*)

Safe:
id 2:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat:*) 2:Nat
# delete types because we do not need them in safe application
=(\x:Nat.x:Nat) 2
=[x->2] x:Nat
=2:Nat

Unsafe:
!(id 2:Nat)
=(\R:*.(id 2:Nat):R) !(typeof(id 2:Nat))
=(\R:*.(id 2:Nat):R) !(typeof(id) 2:Nat)
=(\R:*.(id 2:Nat):R) !((\x:Nat.Nat:*) 2:Nat)
=(\R:*.(id 2:Nat):R) ((\_:*.(\x:Nat.Nat:*) 2:Nat) {~3^check Nat Nat Nat:*})

!(x:X y:Y)
=(\R:*.(x:X y:Y):R) !(typeof(x:X) y:Y)
=(\R:*.(x:X y:Y):R) !(X y:Y)

~2^termEqual: term -> term -> ok|fail

!((\a:A.b:B) y:Y)
if a not in FV(b:B):
  (\_:*. b:B) (~2^termEqual A Y)
else if a not in FV(B):
  (\_:*. (\a:A.b:B) y:Y) (~2^termEqual A Y)
else:
  (\_:*. (\a:A.b:B) y:Y) !((\a:A.B) y:Y)

def t1;t2 === (\_:_. t2) t1 where we do not use the result of t1

!((\a:A.b:B) y:Y)
=
(~2^termEqual A Y); !([a->y]B); ((\a:A.b:B) y:Y)

![a b c]
=![(a b) c]
= (\x. x c) ![(\x.T1.e) b.T2]
= (\x. x c) ({termEqual T1 T2}; ![[x->b]typeof(e)]; (\x.T1.e) b.T2)

= ![({termEqual T1 T2}; ![[x->b]typeof(e)]; (\x.T1.e) b.T2) c]

Goal
![a b c] --> typechecking code; a b c

tru=\t:Nat.\f:Nat.t
=\t:Nat.\f:Nat.t:Nat
=\t:Nat.(\f:Nat.t:Nat):(\f:Nat.Nat)
=(\t:Nat.(\f:Nat.t:Nat):(\f:Nat.Nat)):(\t:Nat.\f:Nat.Nat)



tru 2:Nat 3:Nat
=(\t:Nat.\f:Nat.t) 2:Nat 3:Nat
=(\f:Nat.2) 3
=2

![tru 2:Nat 3:Nat]
=![typeof(true) 2:Nat 3:Nat]; tru 2:Nat 3:Nat
=![(\t:Nat.\f:Nat.Nat) 2:Nat 3:Nat]; tru 2:Nat 3:Nat

![(\t:Nat.\f:Nat.Nat) 2:Nat 3:Nat]

![a b c]
![typeof(a b c)]; a b c
![(\t:Nat.\f:Nat.Nat) 2:Nat 3:Nat]

@==typeof

![(\x:T.a) b]
(\B:*. {= T B}; \x:*.![a]) @[b]:*

dynamic typechecking
id=\x.x
=(\x.x):@[\x.x]

@[\x.x]
=\x.@[x]

((\x.x):(\x.@[x])) 2:Nat
2:@[2]


id=\X:*.\x:X.x

![(a b) c]
=(\x:*. ![x c]) ![a b]

inc=(\x:Nat.x+1):(\x:Nat.Nat:*):*
t[inc]=(\x:Nat.Nat:*):*


https://cs.stackexchange.com/a/81121/163752

I = {1, 2}
X1 = A = {3, 4, 5}
X2 = B = {6}

Px:I.X = X1 * X2 = A * B
= {(a, b) | a in A & b in B}
= {(3,6), (4,6), (5,6)}id=(\x:Nat.x):(\x:Nat.Nat):(\x:Nat.*)
id=(\x:Nat.x):Nat->Nat:*

List::*->*

ss=\x:*->*.

--------------------------------------------------------------------------------
set, term, and type

X = {a, b}
Y = {1, 2}

a1 = (a, 1)
a2 = (a, 2)
b1 = (b, 1)
b2 = (b, 2)

X * Y = {a1, a2, b1, b2}

P - Partial
T - Total
D - Deterministic
S - Stochastic
F - Function

Emty = {}

PDF1 = {a1}
PDF2 = {a2}
PDF3 = {b1}
PDF4 = {b2}

TDF1 = {a1, b1}
TDF2 = {a1, b2}
TDF3 = {a2, b1}
TDF4 = {a2, b2}

PSF1 = {a1, a2}
PSF2 = {b1, b2}

TSF1 = {a1, a2, b1}
TSF2 = {a1, a2, b2}
TSF3 = {b1, b2, a1}
TSF4 = {b1, b2, a2}

Full = X * Y

Power(X*Y) = {Empty, PDF1-4, TDF1-4, PSF1-2, TSF1-4, Full}

Px:X.Y == X -> Y == P(Full)  because Y is constant
Sx:X.Y == X * Y == Full

--------------------------------------------------------------------------------
k=\x:*1.7:Nat
=(\x:*1.7:Nat):(\x:*1.Nat)


k typeof(k)
=(\x:*1.1:Nat) (\x:*1.Nat):*2
Universe inconsistency error


*1->Nat === *1


--------------------------------------------------------------------------------
id = \x:Nat.x

id 2:Nat
=(\x:Nat.x) 2:Nat
=(\A. ((\x.x) 2):A) t[(\x:Nat.x) 2:Nat]
=(\A. ((\x.x) 2):A) ((\x:Nat.t[x]) 2:Nat)
=(\A. ((\x.x) 2):A) ((\x:Nat.Nat) 2:Nat)
=(\A. ((\x.x) 2):A) Nat
=((\x.x) 2):Nat
=2:Nat

ID = \X:*.\x:X.x

ID Nat:*
=(\X:*.\x:X.x) Nat:*
=\x:Nat.x

list = \A:*. 'List[${A}]:*
emptyList = \A:*. (\X:*. '[]:X) (list A)

emptyList Nat:*
=(\A:*. (\X:*. '[]:X) (list A)) Nat:*
=let Y=((\A:*. t[(\X:*. '[]:X) (list A)]) Nat:*) in ((\A. (\X. '[]) (list A)) Nat:*):Y
=let Y=((\A:*. t[(\X:*. '[]:X) (list A)]) Nat:*) in ((\A. (\X. '[]) (list A)) Nat:*):Y

id 2:Nat
=(\x:Nat.x) 2:Nat
=let A=(t[(\x:Nat.x) 2:Nat]) in ((\x.x) 2):A
=let A=(t[(\x:Nat.x)] 2:Nat) in ((\x.x) 2):A
=let A=((\x:Nat.t[x]) 2:Nat) in ((\x.x) 2):A
=let A=((\x:Nat.Nat) 2:Nat) in ((\x.x) 2):A
=let A=Nat in ((\x.x) 2):A
=((\x.x) 2):Nat
=2:Nat

emptyList Nat:*
=(\A:*. (\X:*. '[]:X) (list A)) Nat:*
=let B=(t[(\A:*. (\X:*. '[]:X) (list A)) Nat:*]) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=(t[(\A:*. (\X:*. '[]:X) (list A))] Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=((\A:*. t[(\X:*. '[]:X) (list A)]) Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=((\A:*. t[(\X:*. '[]:X)] (list A)) Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=((\A:*. (\X:*. t['[]:X]) (list A)) Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=((\A:*. (\X:*.X) (list A)) Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B

(\A:*. (\X:*.X) (list A)) Nat:*
=let E=(t[(\A:*. (\X:*.X) (list A)) Nat:*]) in ((\A. (\X.X) (list A)) Nat):E
=let E=(t[(\A:*. (\X:*.X) (list A))] Nat:*) in ((\A. (\X.X) (list A)) Nat):E
=let E=((\A:*. t[(\X:*.X) (list A)]) Nat:*) in ((\A. (\X.X) (list A)) Nat):E
=let E=((\A:*. t[(\X:*.X)] (list A)) Nat:*) in ((\A. (\X.X) (list A)) Nat):E
=let E=((\A:*. (\X:*.t[X]) (list A)) Nat:*) in ((\A. (\X.X) (list A)) Nat):E
=let E=((\A:*. (\X:*.*) (list A)) Nat:*) in ((\A. (\X.X) (list A)) Nat):E


idd = \x:Nat. (\y:Nat.y) x

idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in ((\x. (\y.y) x) 2):A
=let A=(t[(\x:Nat. (\y:Nat.y) x)] 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=((\x:Nat. t[(\y:Nat.y) x]) 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=((\x:Nat. t[(\y:Nat.y)] x) 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=((\x:Nat. (\y:Nat.t[y]) x) 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=((\x:Nat. (\y:Nat.Nat) x) 2:Nat) in ((\x. (\y.y) x) 2):A
--
=let A=((\x:Nat. Nat) 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=Nat in ((\x. (\y.y) x) 2):A
=((\x. (\y.y) x) 2):Nat
=((\y.y) 2):Nat
=2:Nat


idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in (e[(\x:Nat. (\y:Nat.y) x) 2:Nat]):A
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in ((\x. (\y.y) x) 2):A

id 2:Nat
=(\x:Nat.x) 2:Nat

const = \x:Nat.Atom

const 2:Nat
=(\x:Nat.Atom) 2:Nat
={= Nat Nat}; Atom

id 2:Nat
=(\x:Nat.x) 2:Nat
=(\A:*. (e[]):A) (t[])
=(\A:*. (e[(\x:Nat.x) 2:Nat]):A) (t[(\x:Nat.x) 2:Nat])
=(\A:*. ((\x.x) 2):A) (t[(\x:Nat.x)] 2:Nat)
=(\A:*. ((\x.x) 2):A) ((\x:Nat.t[x]) 2:Nat)
=(\A:*. ((\x.x) 2):A) ((\x:Nat.Nat:*) 2:Nat)
=(\A:*. ((\x.x) 2):A) Nat:*

id 2:Nat
=(\x:Nat.x) 2:Nat
=(\A. (e[]):A)


idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let A=(t[]) in (e[]):A
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in (e[(\x:Nat. (\y:Nat.y) x) 2:Nat]):A
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in ((\x. (\y.y) x) 2):A

t[(\x:Nat. (\y:Nat.y) x) 2:Nat]
=let x=2:Nat in t[(\y:Nat.y) x]       G=x:Nat
=let x=2:Nat in let y=x in t[y]       G=x:Nat,y:Nat
=let x=2:Nat in let y=x in Nat       G=x:Nat,y:Nat
=let x=2:Nat in let y=x in Nat
=let y=2 in Nat
=Nat


id 2:Nat
=(\x:Nat.x) 2:Nat
=let x=2:Nat in x
=let x=2:Nat in 

let x=v in e
let R=[x->v]typeof[e] in [x->v]erasure[e]:R


id 2:Nat
=(\x:Nat.x) 2:Nat
=let x=2:Nat in x
~let R=[x->2]typeof[x] in [x->2]erasure[x]:R
~let R=[x->2]Nat in [x->2]x:R
=let R=Nat in 2:R
=2:Nat

idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let a=2:Nat in ((\y:Nat.y) x)
~let R=[x->2]typeof[((\y:Nat.y) x)] in [x->2]erasure[((\y:Nat.y) x)]:R
~let R=[x->2]((\y:Nat.t[y]) x) in [x->2]((\y.y) x):R
~let R=[x->2]((\y:Nat.Nat) x) in [x->2]((\y.y) x):R
=let R=((\y:Nat.Nat) 2) in ((\y.y) 2):R
=let R=Nat in ((\y.y) 2):R
=((\y.y) 2):Nat
=2:Nat

let b=Nat:* in list b
~let R=[b->Nat](typeof[list b]) in [b->Nat](erasure[list b]):R
~let R=[b->Nat]((\A:*. *) b) in [b->Nat]((\A. 'List[${A}]') b):R
~let R=((\A:*. *) Nat) in ((\A. 'List[${A}]') Nat):R

-----

id 2:Nat
=(\x:Nat.x) 2:Nat
=let x=2:Nat in x
=2:Nat

idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let x=2:Nat in (\y:Nat.y) x
=(\y:Nat.y) 2:Nat
=let y=2:Nat in y
=2:Nat

* == 'Type'
list = \A:*. 'List[${A}]':*
emptyList = \A:*. let R=(list A) in '[]':R

emptyList Nat:*
=(\A:*. let R=(list A) in '[]':R) Nat:*
=let A=Nat:* in let R=(list A) in '[]':R
=let R=(list Nat:*) in '[]':R
=let R=((\A:*. 'List[${A}]':*) Nat:*) in '[]':R
=let R=(let A=Nat:* in 'List[${A}]':*) in '[]':R
=let R='List[Nat]':* in '[]':R
='[]':List[Nat]


plus = \a:Nat.\b:Nat.{+ a b}:Nat

plus 2:Nat 3:Nat
=(\a:Nat.\b:Nat.{+ a b}:Nat) 2:Nat 3:Nat
=(let a=2:Nat in \b:Nat.{+ a b}:Nat) 3:Nat
=(\b:Nat.{+ 2 b}:Nat) 3:Nat
=let b=3:Nat in {+ 2 b}:Nat
={+ 2 3}:Nat
=5:Nat

typeof[plus]
=typeof[\a:Nat.\b:Nat.{+ a b}:Nat]
=\a:Nat.b:Nat.Nat
=Nat->Nat->Nat

plus2 = typeit[plus]
=let R=typeof[plus] in erasure[plus]:R
=let R=(\a:Nat.\b:Nat.Nat) in (\a.\b.{+ a b}):R
=let R=Nat->Nat->Nat in (\a.\b.{+ a b}):R
=(\a.\b.{+ a b}):Nat->Nat->Nat

plus2 2:Nat 3:Nat
=((\a.\b.{+ a b}):Nat->Nat->Nat) 2:Nat 3:Nat
=(let a=2:Nat in (\b.{+ a b}):Nat->Nat) 3:Nat
=(\b.{+ 2 b}):Nat->Nat 3:Nat
=let b=3:Nat in {+ 2 b}:Nat
={+ 2 3}:Nat
=5:Nat

id=\x:Nat.x

typeof[id]
=typeof[\x:Nat.x]
=\x:Nat.typeof[x]
=\x:Nat.Nat

typeof[let x=2:Nat in x]
=(\x.x) typeof(2:Nat)
=(\x.x) Nat
=Nat

typeof[let x=Nat:Type in 3:x]
=(\x.typeof(3:x)) Nat
=(\x.x) Nat

typeof[let x=2:Nat in x]
=Nat:Type
=(\x.x:Type) Nat
=(\x.x:Type) typeof(2:Nat)
=(\x:Type.x) typeof(2:Nat)
=(\x:Type.x) Nat:Type
=let x=Nat:Type in x
=Nat:Type

typeof[let x=2:Nat in x]
=let x=typeof(2:Nat) in x
=let x=Nat:Type in x
=Nat:Type

typeof[let x=Nat:Type in List x]
=let x=typeof(Nat:Type) in List x
=let x=Type:Type in List x
=List Type:Type
=(\A:Type. 'List[${A}]':Type) Type:Type
=let A=Type:Type in 'List[${A}]':Type
='List[Type]':Type

let x=Nat:Type in List x
=List Nat:Type
=(\A:Type. 'List[${A}]':Type) Nat:Type
=let A=Nat:Type in 'List[${A}]':Type
='List[Nat]':Type

typeof[let x=Nat:Type in List x]
=Type:Type
=typeof('List[Nat]':Type)
=typeof(let A=Nat:Type in 'List[${A}]':Type)
=typeof((\A:Type. 'List[${A}]':Type) Nat:Type)
=typeof(List Nat:Type)

typeof[let x=Nat:Type in List x]
=let x=Nat:Type in typeof(List x)
=let x=Nat:Type in typeof(List) x
=let x=Nat:Type in typeof(\A:Type. 'List[${A}]':Type) x
=let x=Nat:Type in (\A:Type. typeof('List[${A}]':Type)) x
=let x=Nat:Type in (\A:Type. Type:Type) x
=(\A:Type. Type:Type) Nat:Type
=let R=Nat:Type in Type:Type
=Type:Type

typeof[let x=2:Nat in x]
=Nat:Type
=let x=2:Nat in typeof(x)
=let x=2:Nat in Nat:Type
=Nat:Type

id = \x:Nat.x

typeof[let x=(id 2:Nat) in x]
=let x=(id 2:Nat) in typeof(x)
=let x=(id 2:Nat) in let y=typeof(id 2:Nat) in y
=let x=(id 2:Nat) in let y=(typeof(id) 2:Nat) in y
=let x=(id 2:Nat) in let y=(typeof(\x:Nat.x) 2:Nat) in y
=let x=(id 2:Nat) in let y=((\a:Nat.typeof[a]) 2:Nat) in y
=let x=(id 2:Nat) in let y=((\a:Nat.Nat:Type) 2:Nat) in y
=let x=(id 2:Nat) in let y=(let a=2:Nat in Nat:Type) in y
=let x=(id 2:Nat) in let y=Nat:Type in y
=let x=(id 2:Nat) in Nat:Type
=let x=(id 2:Nat) in Nat:Type

typeof[let x=(id 2:Nat) in x]
=let x=erasure[id 2:Nat]:typeof[id 2:Nat] in typeof[x]
=let x=erasure[(\x:Nat.x) 2:Nat]:typeof[(\x:Nat.x) 2:Nat] in typeof[x]
=let x=((\x.x) 2):(typeof[\x:Nat.x] 2:Nat) in typeof[x]
=let x=((\x.x) 2):((\x:Nat.typeof[x]) 2:Nat) in typeof[x]
=let x=((\x.x) 2):((\x:Nat.Nat:Type) 2:Nat) in typeof[x]
=let x=((\x.x) 2):(let x=2:Nat in Nat:Type) in typeof[x]
=let x=((\x.x) 2):()

------

a=(\x:Nat.x) 2:Nat
typeit[a]
=let R=typeof[a] in erasure[a]:R
  erasure[a]
    =erasure[(\x:Nat.x) 2:Nat]
    =(\x.x) 2
  typeof[a]
    =typeof[(\x:Nat.x) 2:Nat]
    =typeof[\x:Nat.x] 2:Nat
    =(\x:Nat.typeof[x]) 2:Nat
    =(\x:Nat.Nat:Type) 2:Nat
=let R=((\x:Nat.Nat:Type) 2:Nat) in ((\x.x) 2):R
=let R=(let x=2:Nat in Nat:Type) in ((\x.x) 2):R
=let R=Nat:Type in ((\x.x) 2):R
=((\x.x) 2):Nat
=2:Nat

typeof[let x=(id 2:Nat) in x]
=let y=typeof[id 2:Nat] in let x=erasure[id 2:Nat]:y in typeof(x)
=let y=(typeof[id] 2:Nat) in let x=((\x.x) 2):y in y
=let y=((\x:Nat.typeof(x)) 2:Nat) in let x=((\x.x) 2):y in y
=let y=((\x:Nat.Nat:Type) 2:Nat) in let x=((\x.x) 2):y in y
=let y=(let x=2:Nat in Nat:Type) in let x=((\x.x) 2):y in y
=let y=Nat:Type in let x=((\x.x) 2):y in y
=let x=((\x.x) 2):Nat in Nat:Type
  ??? there is no need to evaluate term part when computing type
  maybe introduce lazy keyword

list = \A:Type. 'List[${A}]':Type
let x=Nat:Type in list x
=list Nat:Type
=(\A:Type. 'List[${A}]':Type) Nat:Type
=let A=Nat:Type in 'List[${A}]':Type
='List[Nat]':Type

type[let x=Nat:Type in list x]
=let x=Nat:Type in typeof[list x]
=let x=Nat:Type in typeof[list] x
=let x=Nat:Type in (typeof[\A:Type. 'List[${A}]':Type]) x
=let x=Nat:Type in (\A:Type.typeof['List[${A}]':Type] x)
=let x=Nat:Type in (\A:Type.Type) x
=(\A:Type.Type) Nat:Type
=let A=Nat:Type in Type
=Type

typeof[let x=(id 2:Nat) in x]
=let y=typeof(id 2:Nat) in let lazy y=erasure(id 2:Nat):y in typeof(x)
=let y=Nat:Type in let lazy x=((\x.x) 2):y in y
=let lazy x=((\x.x) 2):Nat in Nat:Type
=Nat:Type

(\x.3):Nat->Nat 2:Nat
=let x=2:Nat in 3:Nat
=3:Nat

(\x.x):Nat->Nat 2:Nat
=let x=2:Nat in x:Nat
=2:Nat
