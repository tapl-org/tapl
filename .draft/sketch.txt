($x:Int. x) 20
($x. x): Int->Int y:Int

check = $funcType.$argType. 

((\x. x) y): check Int->Int Int
((\x. x) y): Int
 

 id = \X. \x:X. x

 id: * -> X -> X
 id: \X. X -> X

 idNat = id Nat
 = (\X. \x:X. x) Nat
 = \x:Nat. x
 idNat: Nat -> Nat

((\X. \x:X. x):(\X. X -> X))
(\X. (\x:X.x): X->X)

id = (\X. \x:X.x): (\X. X->X)

id Nat
= (\X. \x:X.x): (\X. X->X) Nat
[X -> Nat](\x:X. x): [X->Nat](X->X)
\x:Nat. x : Nat->Nat


id = (\x: Nat. x): Nat -> Nat
id 20
((\x: Nat. x): Nat -> Nat) 20
[x->20](\x:Nat. x):[x->20](\x:Nat. Nat)
20: Nat

id = (\x: Nat.x)
= (\x:Nat.x:Nat)
= (\x.x):(\x:Nat.Nat)

id 20
((\x.x):(\x:Nat.Nat)) 20
[x->20](\x.x):(\x:Nat.Nat) 20


\x=Nat.Nat

id = \x:Nat.x
id:typeof(id)
id:\x=Nat.x
id:\x=Nat.Nat
=(\x:Nat.x):(\x=Nat.Nat)

id 20
=((\x:Nat.x):(\x=Nat.Nat)) 20:Nat
=[x->20]x:


id = \x:Nat.x
=(\x:Nat.x:Nat):(\x.Nat)

id 20
=((\x:Nat.x:Nat):(\x.Nat)) 20
=[x->20](x:Nat):[x->20](Nat)
=(20:Nat):Nat
=

id = \x:Nat.x
=(\x.x):(\x=Nat.Nat)

id 20
((\x.x):(\x=Nat.Nat)) 20
((\x.x):(\x.x)) 20:Nat
[x->20]x:[x->Nat]x
20:Nat

((\x.x):(\x=Nat.Nat)) 20:Nat
[x->20]x:[Nat=Nat]Nat
[x->20]x:Nat
20:Nat

((x\.x):(x=Nat.Nat)) 20:Nat
[x\20]x:[Nat=Nat]Nat
[x\20]x:Nat
20:Nat


id = \X. \x:X. x
=\X. \x:X. x:X
=\X. (\x. x):(=X. X)
=(\X. (\x. x)):(=*. (=X. X))

id Nat:*
=(\X. (\x. x)):(=*. (=X. X)) Nat:*
=[Nat\X](\x. x):[*=*](=X. X)
=(\x. x): (=X. X)

id = \X:*. \x:X. x
=\X:*. \x:X. x:X
=\X:*. (\x. x):(\x=X. X)
=(\X. (\x. x)):(\X=*. (\x=X. X))
=\X.\x.x:\X=*.\x=X.X

id Nat:*
= (\X.\x.x:\X=*.\x=X.X) Nat:*
= (\X.\x.x) Nat:* : (\X=*.\x=X.X) Nat:*
= (\X.\x.x) Nat:* : [X->Nat,*=*](\x=X.X)
= (\X.\x.x) Nat:* : (\x=Nat.Nat)
= [X->Nat](\X.\x.x) : (\x=Nat.Nat)
= \x.x : \x=Nat.Nat

(\x.x : \x=Nat.Nat) 20:Nat
= ((\x.x) 20:Nat) : (\x=Nat.Nat) 20:Nat
= [x->20] x : [x->20,Nat=Nat] Nat
= 20 : Nat


id=\X:*.\x:X.x
=\X:*.\x:X.x:X
=\X:*.(\x.x):(\x:X.X)
=(\X.(\x.x)):(\X:*.(\x:X.X))
=\X.\x.x:(\X:*.\x:X.X)

id Nat:*
=(\X.\x.x:(\X:*.\x:X.X)) Nat:*
=((\X.\x.x) Nat):((\X:*.\x:X.X) Nat:*)
=((\X.\x.x) Nat):((\X:*.\x:X.X) Nat:*)
=((\X.\x.x) Nat):((\X.\x:X.X) Nat)
=((\X.\x.x) Nat):([X->Nat](\x:X.X))
=((\X.\x.x) Nat):(\x:Nat.Nat)
=(\x.x):(\x:Nat.Nat)

(\x.x):(\x:Nat.Nat) 20:Nat
=((\x.x) 20):((\x:Nat.Nat) 20:Nat)
=((\x.x) 20):((\x.Nat) 20)
=((\x.x) 20):Nat
=20:Nat


def pair=\a.\b.\f.((f a) b)

def List = \n:Nat. []:<List,n>
=(\n. []):(\n:Nat. <List,n>)

def nil = []:<List,0>
def cons = \n:Nat.\a:<List,n>.\e:Nat. (append a e):<List, + n 1>
= \n:Nat.\a:<List,n>.(\e. append a e):(\e:Nat. <List, + n 1>)
= \n:Nat.(\a.\e. append a e):(\a:<List,n>.(\e:Nat. <List, + n 1>))
= (\n.\a.\e. append a e):(\n:Nat.\a:<List,n>.\e:Nat. <List, + n 1>)

cons 0 nil 1
= (\n.\a.\e. append a e):(\n:Nat.\a:<List,n>.\e:Nat. <List, + n 1>) 0:Nat
= ((\n.\a.\e. append a e) 0):((\n:Nat.\a:<List,n>.\e:Nat. <List, + n 1>) 0:Nat)
= ((\n.\a.\e. append a e) 0):((\n.\a:<List,n>.\e:Nat. <List, + n 1>) 0)
= ((\n.\a.\e. append a e) 0):([n->0](\a:<List,n>.\e:Nat. <List, + n 1>) 0)
= ((\n.\a.\e. append a e) 0):(\a:<List,0>.\e:Nat. <List, + 0 1>)
= ((\n.\a.\e. append a e) 0):(\a:<List,0>.\e:Nat. <List, 1>)
= (\a.\e. append a e):(\a:<List,0>.\e:Nat. <List, 1>)

(\a.\e. append a e):(\a:<List,0>.\e:Nat. <List, 1>) []:<List,0>
=((\a.\e. append a e) []):((\a:<List,0>.\e:Nat. <List, 1>) []:<List,0>)
=((\a.\e. append a e) []):((\a.\e:Nat. <List, 1>) [])
=((\a.\e. append a e) []):(\e:Nat. <List, 1>)
=(\a.\e. append [] e):(\e:Nat. <List, 1>)

(\e. append [] e):(\e:Nat. <List, 1>) 3:Nat
=((\e. append [] e) 3): ((\e:Nat. <List, 1>) 3:Nat)
=((\e. append [] e) 3): ((\e. <List, 1>) 3)
=((\e. append [] e) 3): <List, 1>
=((\e. append [] e) 3): <List, 1>
=(append [] 3): <List, 1>
=[3]: <List, 1>


double = \X:*.\f:X→X.\a:X. f (f a)
Normalize double
=\X:*.\f:X→X.\a:X. f (f a)
=\X:*.\f:X→X.\a:X. f:X→X (f:X→X a:X)
=\X:*.\f:X→X.\a:X. f:X→X (f a):X
=\X:*.\f:X→X.\a:X. (f (f a)):X
=\X:*.\f:X→X.(\a. f (f a)):(\a:X.X)
=\X:*.(\f.\a. f (f a)):(\f:(\x:*.x).\a:X.X)
=(\X.(\f.\a. f (f a))):(\X:*.(\f:(\x:*.x).\a:X.X))
=(\X.\f.\a. f (f a)):(\X:*.\f:(\x:*.x).\a:X.X)



f:X→X a:X
=f:(\X:*.X) X
= (f a):((\X:*.X) X)
= (f a):((\X:*.X) X:*)
= (f a):((\X.X) X)
= (f a):X

f:(\x:*.x) (f a):X
= (f (f a)):((\x:*.x) X)
= (f (f a)):((\x:*.x) X:*)
= (f (f a)):((\x.x) X)
= (f (f a)):X

double Nat
=(\X.\f.\a. f (f a)):(\X:*.\f:(\x:*.x).\a:X.X) Nat
=(\X.\f.\a. f (f a)):(\X:*.\f:(\x:*.x).\a:X.X) Nat:*
=((\X.\f.\a. f (f a)) Nat):((\X:*.\f:(\x:*.x).\a:X.X) Nat:*)
=((\X.\f.\a. f (f a)) Nat):((\X.\f:(\x:*.x).\a:X.X) Nat)
=((\X.\f.\a. f (f a)) Nat):(\f:(\x:*.x).\a:Nat.Nat)

double = \X:*.\f:(x:X.X).\a:X. f (f a)
=\X:*.\f:(x:X.X).\a:X. (f (f a)):X
=\X:*.\f:(x:X.X).(\a.f (f a)):(\a:X. X)
=\X:*.(\f.\a.f (f a)):(\f:(\x:X.X).\a:X. X)
=(\X.\f.\a.f (f a)):(\X:*.\f:(\x:X.X).\a:X.X)

double Nat
=(\X.\f.\a.f (f a)):(\X:*.\f:(\x:X.X).\a:X.X) Nat:*
=((\X.\f.\a.f (f a)) Nat):((\X:*.\f:(\x:X.X).\a:X.X) Nat:*)
=((\X.\f.\a.f (f a)) Nat):((\X.\f:(\x:X.X).\a:X.X) Nat)
=(\f.\a.f (f a)):(\f:(\x:Nat.Nat).\a:Nat.Nat)

inc: (\x:Nat.Nat)


double Nat inc
=(\f.\a.f (f a)):(\f:(\x:Nat.Nat).\a:Nat.Nat) inc:(\x:Nat.Nat)
=((\f.\a.f (f a)) inc):((\f:(\x:Nat.Nat).\a:Nat.Nat) inc:(\x:Nat.Nat))
=((\f.\a.f (f a)) inc):((\f.\a:Nat.Nat) inc)
=((\f.\a.f (f a)) inc):(\a:Nat.Nat)
=(\a.inc (inc a)):(\a:Nat.Nat)

doulbe Nat inc 20:Nat
=(\a.inc (inc a)):(\a:Nat.Nat) 20:Nat
=((\a.inc (inc a)) 20):((\a:Nat.Nat) 20:Nat)
=((\a.inc (inc a)) 20):((\a.Nat) 20)
=((\a.inc (inc a)) 20):Nat
=(inc (inc 20)):Nat
=(inc 21):Nat
=22:Nat


------------

double = \X:*. \f:(\x:X.X). \a:X. f (f a)


id = \X:*.\x:X.x
=(\X.\x.x):(\X:*.\x:X.X)


def Nat:*

def idNat = \x:Nat.x
=\x:Nat.x:Nat


idNat 20:Nat
=(\x:Nat.x:Nat) 20:Nat
=20:Nat

id = \X:*.\x:X.x
=\X:*.\x:X.x:X

id Nat:*
=(\X:*.\x:X.x:X) Nat:*
=\x:Nat.x:Nat


double = \X:*.\f:(\y:X.X).\a:X. f (f a)
=\X:*.\f:(\y:X.X).\a:X. f:(\y:X.X) (f:(\y:X.X) a:X)
=\X:*.\f:(\y:X.X).\a:X. f:(\y:X.X) (f:(\y:X.X) a:X):((\y:X.X) a:X)
=\X:*.\f:(\y:X.X).\a:X. f:(\y:X.X) (f:(\y:X.X) a:X):X
=\X:*.\f:(\y:X.X).\a:X. (f:(\y:X.X) (f:(\y:X.X) a:X):X):X 


double Nat:*
=(\X:*.\f:(\y:X.X).\a:X. (f:(\y:X.X) (f:(\y:X.X) a:X):X):X) Nat:*
=\f:(\y:Nat.Nat).\a:Nat. (f:(\y:Nat.Nat) (f:(\y:Nat.Nat) a:Nat):Nat):Nat

inc:(\x:Nat.Nat)

double Nat inc
=(\f:(\y:Nat.Nat).\a:Nat. (f:(\y:Nat.Nat) (f:(\y:Nat.Nat) a:Nat):Nat):Nat) inc:(\x:Nat.Nat)
=[f -> (\x:Nat. succ x)](\a:Nat. (f:(\y:Nat.Nat) (f:(\y:Nat.Nat) a:Nat):Nat):Nat)
=(\a:Nat. ((\x:Nat. succ x):(\y:Nat.Nat) ((\x:Nat. succ x):(\y:Nat.Nat) a:Nat):Nat):Nat)
=(\a:Nat. ((\x:Nat. succ x):(\y:Nat.Nat) (succ a)):Nat):Nat)

doulbeD = \f:(\y:d.d:*).\a:d. (f (f a)):d

inc=\y:d.y:d
=(\y.y):(\y:d.d)

doubleD inc
=(\f:(\y:d.d).\a:d. (f (f a)):d) inc
=

\x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):Nat->Nat

id=\x:Nat.x
=\x:Nat.x:Nat
=\x:Nat.x:Nat:*

id 20:Nat:*
=(\x:Nat:*.x:Nat:*) 20:Nat:*
=[x->20]x:Nat:*
=20:Nat:*

=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):Nat->Nat
=(\x:Nat.x:Nat):Nat->Nat:*

=\x:Nat. newList:(\x:Nat.List[x:Nat]) x:Nat
=\x:Nat. (newList:(\x:Nat.List[x:Nat]) x:Nat):((\x:Nat.List[x:Nat]) x:Nat)
=\x:Nat. (newList:(\x:Nat.List[x:Nat]) x:Nat):List[x:Nat]
=(\x:Nat. (newList:(\x:Nat.List[x:Nat]) x:Nat):List[x:Nat]):(\x:Nat.List[x:Nat])
=(\x:Nat. (newList:(\x:Nat.List[x:Nat]) x:Nat):List[x:Nat]):(\x:Nat.List[x:Nat]:*)
  :(\x:Nat.*)
  :(Nat:*)->*:*


=λY. λZ. ∀X. (Y→Z→X) → X
=λY. λZ. ∀X. (Y→Z→X) → X


pairNat = λn1:CNat. λn2:CNat. λX. λf:CNat→CNat→X. f n1 n2;
fstNat = λp:PairNat. p [CNat] (λn1:CNat. λn2:CNat. n1); 
sndNat = λp:PairNat. p [CNat] (λn1:CNat. λn2:CNat. n2);

CBool = ∀X.X→X→X;
tru = λX. λt:X. λf:X. t;
fls = λX. λt:X. λf:X. f;

tru = \X. \t:X. \f:X. t
=\X:*.\t:X.\f:X.t
=\X:*.\t:X.\f:X.t:X
=\X:*.\t:X.(\f:X.t:X):(\f:X.X)
=\X:*.(\t:X.(\f:X.t:X):(\f:X.X)):(\t:X.\f:X.X)
=(\X:*.(\t:X.(\f:X.t:X):(\f:X.X)):(\t:X.\f:X.X)):(\X:*.\t:X.\f:X.X)

(\X:*.\t:X.\f:X.X)
=(\X:*.X→X→X) == ∀X.X→X→X

Universal type
id = λX. λx:X. x;
=\X:*.\x:X.x:X
=\X:*.(\x:X.x:X):(\x:X.X:*)
=(\X:*.(\x:X.x:X):(\x:X.X:*)):(\X:*.\x:X.X:*)

=(\X:*.\x:X.X:*)

(\X.\x:X.x:X):(\X.X->X)
(\X.\x:X.x:X):(∀X.X→X)


List=\a:Nat.[0*a]:'List_$a'

List 2
=(\a:Nat.[0*a]:'List_$a') 2:Nat
=[0,0]:'List_2'

id = \x:Nat.x


id 2:Nat
=\x:Nat.x 2:Nat
=\x:Nat.x:Nat 2:Nat
=2:Nat

id=\X.\x:X.x

id Nat 2:Nat
=(\X:*.\x:X.x) Nat 2:Nat
=(\X:*.\x:X.x:X) Nat:* 2:Nat
=(\X:*.\x:X.x:X) Nat:* 2:Nat


=(\X:*.\x:X.x:X)
=(\X:*.(\x:X.x:X):(\x:X.X))
=(\X:*.(\x:X.x:X):(\x:X.X)):(\X:*.(\x:X.X))

=\x:Nat.x:Nat
=(\x:Nat.x:Nat):Nat->Nat

id = \x:Nat.x
=\x:Nat.x:Nat

id 2:Nat
=(\x:Nat.x:Nat) 2:Nat
=((\x:Nat.x:Nat)!2):((\x:Nat.Nat) 2:Nat)
=((\x:Nat.x:Nat)!2):((\x:Nat.Nat) 2:Nat)


4:Nat

(add1:(\x:Nat.Nat) 4:Nat):Nat
=(5:Nat):Nat
=5:Nat

id=\X:*.\x:X.x
=\X:*.\x:X.x:X
=(\X:*.(\x:X.x:X):(\x:X.X))
=(\X:*.(\x:X.x:X):(\x:X.X)):(\X:*.\x:X.X)

id = \x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):(\x:Nat.Nat:*)
=(\x:Nat.x:Nat):(\x:Nat.Nat:*):*


id 2:Nat:*
=(\x:Nat:*.x:Nat:*):(\x:Nat:*.Nat:*):* 2:Nat:*
=((\x:Nat:*.x:Nat:*)!2):((\x:Nat:*.Nat:*):* 2:Nat:*)
=((\x:Nat:*.x:Nat:*)!2):((\x:Nat:*.Nat:*):* 2:Nat:*)
=((\x:Nat:*.x:Nat:*)!2):((\x:Nat:*.Nat:*)!2):(* 2:Nat:*)   error
=((\x:Nat:*.x:Nat:*)!2):((\x:Nat:*.Nat:*)!2):*
=((\x:Nat:*.x:Nat:*)!2):(Nat:*):*
=((\x:Nat:*.x:Nat:*)!2):Nat:*
=((\x:Nat:*.x:Nat:*)!2):Nat:*
=(2:Nat:*):Nat:*
=2:Nat:*

id = \x:Nat.x
=\x:Nat:*.x:Nat:*
=(\x:Nat:*.x:Nat:*):(\x:Nat:*.Nat:*)
=(\x:Nat:*.x:Nat:*):(Nat:*->Nat:*)
=(\x:Nat:*.x:Nat:*):(Nat:*->Nat:*):*

id 2:Nat:*
=(\x:Nat:*.x:Nat:*):(Nat:*->Nat:*):* 2:Nat:*
=((\x:Nat:*.x:Nat:*)!2):((Nat:*->Nat:*):* 2:Nat:*)


id = \x:Nat.x

id 2:Nat
=(id 2:Nat):t[id 2:Nat]
=(id 2:Nat):t[id 2:Nat]

t[id 2:Nat]
=t[id] 2:Nat
=t[\x:Nat.x] 2:Nat
=\x:Nat.t[x] 2:Nat
=\x:Nat.Nat 2:Nat

=(id 2:Nat):(\x:Nat.Nat 2:Nat)
=(id 2:Nat): (Nat->Nat 2:Nat)

id = \x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)

id 2:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat
=((\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat):((\x:Nat.Nat) 2:Nat)

t
eval(t)
=t:typeof(t)
if typeof(t) is binary or type-of-function
  eval(t)
else:
  eval(typeof(t))


(\x:A.y:B) z:C
=((\x:A.y:B) z:C):(A=C->B)

(\x:Nat.x:Nat) 2:A
=((\x:Nat.x:Nat) 2:A):((\x:Nat.Nat) 2:A)
=((\x:Nat.x:Nat) 2:A):((\Nat<=?.Nat) A)
=((\x:Nat.x:Nat) 2:A):

t:(\x:A.b) z:C
if A == C: beta-reduction -> [x->z]b
elif A != C: raise type-error
else: type-it -> (t:(\x:A.b) z:C):((\x:A.b) z:C)

(\a:A.b:B) c:C
if A==C:
  beta-reduction -> [a->c]b:B
elif A!=C:
  raise type-error
elif a not in FV(B):
  ((\a:A.b:B) c:C):A=C->B
else:
  stuck

\x:Nat.x:Nat 2:Nat
2:Nat

\X:*.\x:X.x:X Nat:* 2:Nat
=\x:Nat.x:Nat 2:Nat
=2:Nat


(\a:A.b:B) c:C
=((\a:A.b:B) c:C):((\x:Unit.(\x:A.B) c:C) (equiv A C))

Operators
=[T1,T2, t]  equivalent
$[t]      evaluation (unprotected call)
@[t]      typeof
%[t]      erasure


$[(\a:A.b:B) c:C]
> [a->c]b:B

@[(\a:A.b:B) c:C]
> (\a:A.B) c:C
> if a not in b:B then: =[A,C, B]
> else: =[A,C, $[(\a:A.B) c:C]]


((\a:A.b:B) c:C):(=[A,C, $[(\a:A.B) c:C]])


@[(\x:Nat.x:Nat) 2:Nat]
> =[Nat, Nat, $[(\x:Nat.Nat) 2:Nat]]
> =[Nat, Nat, Nat]
> Nat

$[(\a:A.b:B) c:C]:@[(\x:Nat.x:Nat) 2:Nat]
> $[(\a:A.b:B) c:C]:Nat
> [a->c]b:B:Nat


(\x:Nat.x) 2:Nat

eval[(\x:Nat.x) 2:Nat]:typeof[(\x:Nat.x) 2:Nat]


typeof[(\x:Nat.x) 2:Nat]
> (\x:Nat.Nat) 2:Nat


(\a:A.b:B) c:C

typeof[(\a:A.b:B) c:C]
> typeof[(\a:A.b:B)] c:C
> (\a:A.typeof(b:B)) c:C
> (\a:A.B) c:C

((\a:A.b:B) c:C):(if (= A C) ((\a:A.B) c:C) error)
((\a:A.b:B) c:C):M[A, C, ((\a:A.B) c:C)]

typeof(\x:Nat.x)
\x:Nat.typeof(x)
\x:Nat.Nat

typeof(id 2:Nat)
typecheck(typeof(id) 2:Nat)
\x:Nat.Nat 2:Nat
Nat

id = \x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)

id 2:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat
=((\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat):((\x:Nat.Nat) 2:Nat)
=((\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat):(TRW [Nat Nat Nat])
=((\x:Nat.x:Nat):(\x:Nat.Nat) 2:Nat):Nat


eval(id 2:Nat)
=eval(\x:Nat.x 2:Nat)
=2

typeof(id 2:Nat)
=eval(typeof(id) 2:Nat)
=eval(\x:Nat.Nat 2:Nat)
=Nat

\x:A.t:T

     x in FV(t)      x in FV(T)
#A       false           false          closed value: For example: function type A->t
#B       false           true           dependent type
#C       true            false          function
#D       true            true           dependent type & function

id = \x:Nat.x
=\x:Nat.x:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat)
=(\x:Nat.x:Nat):(\x:Nat.Nat:*)

Safe:
id 2:Nat
=(\x:Nat.x:Nat):(\x:Nat.Nat:*) 2:Nat
# delete types because we do not need them in safe application
=(\x:Nat.x:Nat) 2
=[x->2] x:Nat
=2:Nat

Unsafe:
!(id 2:Nat)
=(\R:*.(id 2:Nat):R) !(typeof(id 2:Nat))
=(\R:*.(id 2:Nat):R) !(typeof(id) 2:Nat)
=(\R:*.(id 2:Nat):R) !((\x:Nat.Nat:*) 2:Nat)
=(\R:*.(id 2:Nat):R) ((\_:*.(\x:Nat.Nat:*) 2:Nat) {~3^check Nat Nat Nat:*})

!(x:X y:Y)
=(\R:*.(x:X y:Y):R) !(typeof(x:X) y:Y)
=(\R:*.(x:X y:Y):R) !(X y:Y)

~2^termEqual: term -> term -> ok|fail

!((\a:A.b:B) y:Y)
if a not in FV(b:B):
  (\_:*. b:B) (~2^termEqual A Y)
else if a not in FV(B):
  (\_:*. (\a:A.b:B) y:Y) (~2^termEqual A Y)
else:
  (\_:*. (\a:A.b:B) y:Y) !((\a:A.B) y:Y)

def t1;t2 === (\_:_. t2) t1 where we do not use the result of t1

!((\a:A.b:B) y:Y)
=
(~2^termEqual A Y); !([a->y]B); ((\a:A.b:B) y:Y)

![a b c]
=![(a b) c]
= (\x. x c) ![(\x.T1.e) b.T2]
= (\x. x c) ({termEqual T1 T2}; ![[x->b]typeof(e)]; (\x.T1.e) b.T2)

= ![({termEqual T1 T2}; ![[x->b]typeof(e)]; (\x.T1.e) b.T2) c]

Goal
![a b c] --> typechecking code; a b c

tru=\t:Nat.\f:Nat.t
=\t:Nat.\f:Nat.t:Nat
=\t:Nat.(\f:Nat.t:Nat):(\f:Nat.Nat)
=(\t:Nat.(\f:Nat.t:Nat):(\f:Nat.Nat)):(\t:Nat.\f:Nat.Nat)



tru 2:Nat 3:Nat
=(\t:Nat.\f:Nat.t) 2:Nat 3:Nat
=(\f:Nat.2) 3
=2

![tru 2:Nat 3:Nat]
=![typeof(true) 2:Nat 3:Nat]; tru 2:Nat 3:Nat
=![(\t:Nat.\f:Nat.Nat) 2:Nat 3:Nat]; tru 2:Nat 3:Nat

![(\t:Nat.\f:Nat.Nat) 2:Nat 3:Nat]

![a b c]
![typeof(a b c)]; a b c
![(\t:Nat.\f:Nat.Nat) 2:Nat 3:Nat]

@==typeof

![(\x:T.a) b]
(\B:*. {= T B}; \x:*.![a]) @[b]:*

dynamic typechecking
id=\x.x
=(\x.x):@[\x.x]

@[\x.x]
=\x.@[x]

((\x.x):(\x.@[x])) 2:Nat
2:@[2]


id=\X:*.\x:X.x

![(a b) c]
=(\x:*. ![x c]) ![a b]

inc=(\x:Nat.x+1):(\x:Nat.Nat:*):*
t[inc]=(\x:Nat.Nat:*):*


https://cs.stackexchange.com/a/81121/163752

I = {1, 2}
X1 = A = {3, 4, 5}
X2 = B = {6}

Px:I.X = X1 * X2 = A * B
= {(a, b) | a in A & b in B}
= {(3,6), (4,6), (5,6)}id=(\x:Nat.x):(\x:Nat.Nat):(\x:Nat.*)
id=(\x:Nat.x):Nat->Nat:*

List::*->*

ss=\x:*->*.

--------------------------------------------------------------------------------
set, term, and type

X = {a, b}
Y = {1, 2}

a1 = (a, 1)
a2 = (a, 2)
b1 = (b, 1)
b2 = (b, 2)

X * Y = {a1, a2, b1, b2}

P - Partial
T - Total
D - Deterministic
S - Stochastic
F - Function

Emty = {}

PDF1 = {a1}
PDF2 = {a2}
PDF3 = {b1}
PDF4 = {b2}

TDF1 = {a1, b1}
TDF2 = {a1, b2}
TDF3 = {a2, b1}
TDF4 = {a2, b2}

PSF1 = {a1, a2}
PSF2 = {b1, b2}

TSF1 = {a1, a2, b1}
TSF2 = {a1, a2, b2}
TSF3 = {b1, b2, a1}
TSF4 = {b1, b2, a2}

Full = X * Y

Power(X*Y) = {Empty, PDF1-4, TDF1-4, PSF1-2, TSF1-4, Full}

Px:X.Y == X -> Y == P(Full)  because Y is constant
Sx:X.Y == X * Y == Full

--------------------------------------------------------------------------------
k=\x:*1.7:Nat
=(\x:*1.7:Nat):(\x:*1.Nat)


k typeof(k)
=(\x:*1.1:Nat) (\x:*1.Nat):*2
Universe inconsistency error


*1->Nat === *1


--------------------------------------------------------------------------------
id = \x:Nat.x

id 2:Nat
=(\x:Nat.x) 2:Nat
=(\A. ((\x.x) 2):A) t[(\x:Nat.x) 2:Nat]
=(\A. ((\x.x) 2):A) ((\x:Nat.t[x]) 2:Nat)
=(\A. ((\x.x) 2):A) ((\x:Nat.Nat) 2:Nat)
=(\A. ((\x.x) 2):A) Nat
=((\x.x) 2):Nat
=2:Nat

ID = \X:*.\x:X.x

ID Nat:*
=(\X:*.\x:X.x) Nat:*
=\x:Nat.x

list = \A:*. 'List[${A}]:*
emptyList = \A:*. (\X:*. '[]:X) (list A)

emptyList Nat:*
=(\A:*. (\X:*. '[]:X) (list A)) Nat:*
=let Y=((\A:*. t[(\X:*. '[]:X) (list A)]) Nat:*) in ((\A. (\X. '[]) (list A)) Nat:*):Y
=let Y=((\A:*. t[(\X:*. '[]:X) (list A)]) Nat:*) in ((\A. (\X. '[]) (list A)) Nat:*):Y

id 2:Nat
=(\x:Nat.x) 2:Nat
=let A=(t[(\x:Nat.x) 2:Nat]) in ((\x.x) 2):A
=let A=(t[(\x:Nat.x)] 2:Nat) in ((\x.x) 2):A
=let A=((\x:Nat.t[x]) 2:Nat) in ((\x.x) 2):A
=let A=((\x:Nat.Nat) 2:Nat) in ((\x.x) 2):A
=let A=Nat in ((\x.x) 2):A
=((\x.x) 2):Nat
=2:Nat

emptyList Nat:*
=(\A:*. (\X:*. '[]:X) (list A)) Nat:*
=let B=(t[(\A:*. (\X:*. '[]:X) (list A)) Nat:*]) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=(t[(\A:*. (\X:*. '[]:X) (list A))] Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=((\A:*. t[(\X:*. '[]:X) (list A)]) Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=((\A:*. t[(\X:*. '[]:X)] (list A)) Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=((\A:*. (\X:*. t['[]:X]) (list A)) Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B
=let B=((\A:*. (\X:*.X) (list A)) Nat:*) in ((\A. (\X. '[]) (list A)) Nat):B

(\A:*. (\X:*.X) (list A)) Nat:*
=let E=(t[(\A:*. (\X:*.X) (list A)) Nat:*]) in ((\A. (\X.X) (list A)) Nat):E
=let E=(t[(\A:*. (\X:*.X) (list A))] Nat:*) in ((\A. (\X.X) (list A)) Nat):E
=let E=((\A:*. t[(\X:*.X) (list A)]) Nat:*) in ((\A. (\X.X) (list A)) Nat):E
=let E=((\A:*. t[(\X:*.X)] (list A)) Nat:*) in ((\A. (\X.X) (list A)) Nat):E
=let E=((\A:*. (\X:*.t[X]) (list A)) Nat:*) in ((\A. (\X.X) (list A)) Nat):E
=let E=((\A:*. (\X:*.*) (list A)) Nat:*) in ((\A. (\X.X) (list A)) Nat):E


idd = \x:Nat. (\y:Nat.y) x

idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in ((\x. (\y.y) x) 2):A
=let A=(t[(\x:Nat. (\y:Nat.y) x)] 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=((\x:Nat. t[(\y:Nat.y) x]) 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=((\x:Nat. t[(\y:Nat.y)] x) 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=((\x:Nat. (\y:Nat.t[y]) x) 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=((\x:Nat. (\y:Nat.Nat) x) 2:Nat) in ((\x. (\y.y) x) 2):A
--
=let A=((\x:Nat. Nat) 2:Nat) in ((\x. (\y.y) x) 2):A
=let A=Nat in ((\x. (\y.y) x) 2):A
=((\x. (\y.y) x) 2):Nat
=((\y.y) 2):Nat
=2:Nat


idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in (e[(\x:Nat. (\y:Nat.y) x) 2:Nat]):A
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in ((\x. (\y.y) x) 2):A

id 2:Nat
=(\x:Nat.x) 2:Nat

const = \x:Nat.Atom

const 2:Nat
=(\x:Nat.Atom) 2:Nat
={= Nat Nat}; Atom

id 2:Nat
=(\x:Nat.x) 2:Nat
=(\A:*. (e[]):A) (t[])
=(\A:*. (e[(\x:Nat.x) 2:Nat]):A) (t[(\x:Nat.x) 2:Nat])
=(\A:*. ((\x.x) 2):A) (t[(\x:Nat.x)] 2:Nat)
=(\A:*. ((\x.x) 2):A) ((\x:Nat.t[x]) 2:Nat)
=(\A:*. ((\x.x) 2):A) ((\x:Nat.Nat:*) 2:Nat)
=(\A:*. ((\x.x) 2):A) Nat:*

id 2:Nat
=(\x:Nat.x) 2:Nat
=(\A. (e[]):A)


idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let A=(t[]) in (e[]):A
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in (e[(\x:Nat. (\y:Nat.y) x) 2:Nat]):A
=let A=(t[(\x:Nat. (\y:Nat.y) x) 2:Nat]) in ((\x. (\y.y) x) 2):A

t[(\x:Nat. (\y:Nat.y) x) 2:Nat]
=let x=2:Nat in t[(\y:Nat.y) x]       G=x:Nat
=let x=2:Nat in let y=x in t[y]       G=x:Nat,y:Nat
=let x=2:Nat in let y=x in Nat       G=x:Nat,y:Nat
=let x=2:Nat in let y=x in Nat
=let y=2 in Nat
=Nat


id 2:Nat
=(\x:Nat.x) 2:Nat
=let x=2:Nat in x
=let x=2:Nat in 

let x=v in e
let R=[x->v]typeof[e] in [x->v]erasure[e]:R


id 2:Nat
=(\x:Nat.x) 2:Nat
=let x=2:Nat in x
~let R=[x->2]typeof[x] in [x->2]erasure[x]:R
~let R=[x->2]Nat in [x->2]x:R
=let R=Nat in 2:R
=2:Nat

idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let a=2:Nat in ((\y:Nat.y) x)
~let R=[x->2]typeof[((\y:Nat.y) x)] in [x->2]erasure[((\y:Nat.y) x)]:R
~let R=[x->2]((\y:Nat.t[y]) x) in [x->2]((\y.y) x):R
~let R=[x->2]((\y:Nat.Nat) x) in [x->2]((\y.y) x):R
=let R=((\y:Nat.Nat) 2) in ((\y.y) 2):R
=let R=Nat in ((\y.y) 2):R
=((\y.y) 2):Nat
=2:Nat

let b=Nat:* in list b
~let R=[b->Nat](typeof[list b]) in [b->Nat](erasure[list b]):R
~let R=[b->Nat]((\A:*. *) b) in [b->Nat]((\A. 'List[${A}]') b):R
~let R=((\A:*. *) Nat) in ((\A. 'List[${A}]') Nat):R

-----

id 2:Nat
=(\x:Nat.x) 2:Nat
=let x=2:Nat in x
=2:Nat

idd 2:Nat
=(\x:Nat. (\y:Nat.y) x) 2:Nat
=let x=2:Nat in (\y:Nat.y) x
=(\y:Nat.y) 2:Nat
=let y=2:Nat in y
=2:Nat

* == 'Type'
list = \A:*. 'List[${A}]':*
emptyList = \A:*. let R=(list A) in '[]':R

emptyList Nat:*
=(\A:*. let R=(list A) in '[]':R) Nat:*
=let A=Nat:* in let R=(list A) in '[]':R
=let R=(list Nat:*) in '[]':R
=let R=((\A:*. 'List[${A}]':*) Nat:*) in '[]':R
=let R=(let A=Nat:* in 'List[${A}]':*) in '[]':R
=let R='List[Nat]':* in '[]':R
='[]':List[Nat]


plus = \a:Nat.\b:Nat.{+ a b}:Nat

plus 2:Nat 3:Nat
=(\a:Nat.\b:Nat.{+ a b}:Nat) 2:Nat 3:Nat
=(let a=2:Nat in \b:Nat.{+ a b}:Nat) 3:Nat
=(\b:Nat.{+ 2 b}:Nat) 3:Nat
=let b=3:Nat in {+ 2 b}:Nat
={+ 2 3}:Nat
=5:Nat

typeof[plus]
=typeof[\a:Nat.\b:Nat.{+ a b}:Nat]
=\a:Nat.b:Nat.Nat
=Nat->Nat->Nat

plus2 = typeit[plus]
=let R=typeof[plus] in erasure[plus]:R
=let R=(\a:Nat.\b:Nat.Nat) in (\a.\b.{+ a b}):R
=let R=Nat->Nat->Nat in (\a.\b.{+ a b}):R
=(\a.\b.{+ a b}):Nat->Nat->Nat

plus2 2:Nat 3:Nat
=((\a.\b.{+ a b}):Nat->Nat->Nat) 2:Nat 3:Nat
=(let a=2:Nat in (\b.{+ a b}):Nat->Nat) 3:Nat
=(\b.{+ 2 b}):Nat->Nat 3:Nat
=let b=3:Nat in {+ 2 b}:Nat
={+ 2 3}:Nat
=5:Nat

id=\x:Nat.x

typeof[id]
=typeof[\x:Nat.x]
=\x:Nat.typeof[x]
=\x:Nat.Nat

typeof[let x=2:Nat in x]
=(\x.x) typeof(2:Nat)
=(\x.x) Nat
=Nat

typeof[let x=Nat:Type in 3:x]
=(\x.typeof(3:x)) Nat
=(\x.x) Nat

typeof[let x=2:Nat in x]
=Nat:Type
=(\x.x:Type) Nat
=(\x.x:Type) typeof(2:Nat)
=(\x:Type.x) typeof(2:Nat)
=(\x:Type.x) Nat:Type
=let x=Nat:Type in x
=Nat:Type

typeof[let x=2:Nat in x]
=let x=typeof(2:Nat) in x
=let x=Nat:Type in x
=Nat:Type

typeof[let x=Nat:Type in List x]
=let x=typeof(Nat:Type) in List x
=let x=Type:Type in List x
=List Type:Type
=(\A:Type. 'List[${A}]':Type) Type:Type
=let A=Type:Type in 'List[${A}]':Type
='List[Type]':Type

let x=Nat:Type in List x
=List Nat:Type
=(\A:Type. 'List[${A}]':Type) Nat:Type
=let A=Nat:Type in 'List[${A}]':Type
='List[Nat]':Type

typeof[let x=Nat:Type in List x]
=Type:Type
=typeof('List[Nat]':Type)
=typeof(let A=Nat:Type in 'List[${A}]':Type)
=typeof((\A:Type. 'List[${A}]':Type) Nat:Type)
=typeof(List Nat:Type)

typeof[let x=Nat:Type in List x]
=let x=Nat:Type in typeof(List x)
=let x=Nat:Type in typeof(List) x
=let x=Nat:Type in typeof(\A:Type. 'List[${A}]':Type) x
=let x=Nat:Type in (\A:Type. typeof('List[${A}]':Type)) x
=let x=Nat:Type in (\A:Type. Type:Type) x
=(\A:Type. Type:Type) Nat:Type
=let R=Nat:Type in Type:Type
=Type:Type

typeof[let x=2:Nat in x]
=Nat:Type
=let x=2:Nat in typeof(x)
=let x=2:Nat in Nat:Type
=Nat:Type

id = \x:Nat.x

typeof[let x=(id 2:Nat) in x]
=let x=(id 2:Nat) in typeof(x)
=let x=(id 2:Nat) in let y=typeof(id 2:Nat) in y
=let x=(id 2:Nat) in let y=(typeof(id) 2:Nat) in y
=let x=(id 2:Nat) in let y=(typeof(\x:Nat.x) 2:Nat) in y
=let x=(id 2:Nat) in let y=((\a:Nat.typeof[a]) 2:Nat) in y
=let x=(id 2:Nat) in let y=((\a:Nat.Nat:Type) 2:Nat) in y
=let x=(id 2:Nat) in let y=(let a=2:Nat in Nat:Type) in y
=let x=(id 2:Nat) in let y=Nat:Type in y
=let x=(id 2:Nat) in Nat:Type
=let x=(id 2:Nat) in Nat:Type

typeof[let x=(id 2:Nat) in x]
=let x=erasure[id 2:Nat]:typeof[id 2:Nat] in typeof[x]
=let x=erasure[(\x:Nat.x) 2:Nat]:typeof[(\x:Nat.x) 2:Nat] in typeof[x]
=let x=((\x.x) 2):(typeof[\x:Nat.x] 2:Nat) in typeof[x]
=let x=((\x.x) 2):((\x:Nat.typeof[x]) 2:Nat) in typeof[x]
=let x=((\x.x) 2):((\x:Nat.Nat:Type) 2:Nat) in typeof[x]
=let x=((\x.x) 2):(let x=2:Nat in Nat:Type) in typeof[x]
=let x=((\x.x) 2):()

------

a=(\x:Nat.x) 2:Nat
typeit[a]
=let R=typeof[a] in erasure[a]:R
  erasure[a]
    =erasure[(\x:Nat.x) 2:Nat]
    =(\x.x) 2
  typeof[a]
    =typeof[(\x:Nat.x) 2:Nat]
    =typeof[\x:Nat.x] 2:Nat
    =(\x:Nat.typeof[x]) 2:Nat
    =(\x:Nat.Nat:Type) 2:Nat
=let R=((\x:Nat.Nat:Type) 2:Nat) in ((\x.x) 2):R
=let R=(let x=2:Nat in Nat:Type) in ((\x.x) 2):R
=let R=Nat:Type in ((\x.x) 2):R
=((\x.x) 2):Nat
=2:Nat

typeof[let x=(id 2:Nat) in x]
=let y=typeof[id 2:Nat] in let x=erasure[id 2:Nat]:y in typeof(x)
=let y=(typeof[id] 2:Nat) in let x=((\x.x) 2):y in y
=let y=((\x:Nat.typeof(x)) 2:Nat) in let x=((\x.x) 2):y in y
=let y=((\x:Nat.Nat:Type) 2:Nat) in let x=((\x.x) 2):y in y
=let y=(let x=2:Nat in Nat:Type) in let x=((\x.x) 2):y in y
=let y=Nat:Type in let x=((\x.x) 2):y in y
=let x=((\x.x) 2):Nat in Nat:Type
  ??? there is no need to evaluate term part when computing type
  maybe introduce lazy keyword

list = \A:Type. 'List[${A}]':Type
let x=Nat:Type in list x
=list Nat:Type
=(\A:Type. 'List[${A}]':Type) Nat:Type
=let A=Nat:Type in 'List[${A}]':Type
='List[Nat]':Type

type[let x=Nat:Type in list x]
=let x=Nat:Type in typeof[list x]
=let x=Nat:Type in typeof[list] x
=let x=Nat:Type in (typeof[\A:Type. 'List[${A}]':Type]) x
=let x=Nat:Type in (\A:Type.typeof['List[${A}]':Type] x)
=let x=Nat:Type in (\A:Type.Type) x
=(\A:Type.Type) Nat:Type
=let A=Nat:Type in Type
=Type

typeof[let x=(id 2:Nat) in x]
=let y=typeof(id 2:Nat) in let lazy y=erasure(id 2:Nat):y in typeof(x)
=let y=Nat:Type in let lazy x=((\x.x) 2):y in y
=let lazy x=((\x.x) 2):Nat in Nat:Type
=Nat:Type

(\x.3):Nat->Nat 2:Nat
=let x=2:Nat in 3:Nat
=3:Nat

(\x.x):Nat->Nat 2:Nat
=let x=2:Nat in x:Nat
=2:Nat

typeof[\x:Nat.x]
=\x:Nat.typeof[x]
=\x:Nat.Nat:Type
=Nat->Nat:Type

typeit[\x:Nat.x]
=let r=typeof[\x:Nat.x] in erasure[\x:Nat.x]:r
=let r=\x:Nat.Nat:Type in (\x.x):r

typeof(\x:Nat.Nat:Type)
=\x:Nat.Type:Type

typeof[(\x:Nat.x) 2:Nat]
=typeof[\x:Nat.x] 2:Nat
=(\x:Nat.typeof[x]) 2:Nat
=(\x:Nat.Nat:*) 2:Nat
=let x=2:Nat in Nat:*
=Nat:*


typeof[\x:*.2:x]
=\x:*.x:*
=Ax.x

(\x:*.2:x) Nat:*
=let x=Nat:* in 2:x
=2:Nat

???
let y=(\x:*.x:*) in (\x.2):y

(\x.x):Nat->Nat 2:Nat
=((\x.x) 2):Nat
=2:Nat

let Y=(\x:*.2:x) in Y Nat:*
=(\x:*.2:x) Nat:*
=let x=Nat:* in 2:x
2:Nat

(\Y:(Ax.x).Y Nat:*) (\x:*.2:x)
=(\Y:(Ax.x).Y Nat:*) (\x.2):(Ax.x)
=let Y=(\x.2):(Ax.x) in Y Nat:*
=(\x.2):(Ax.x) Nat:*
=((\x.2) Nat)


id=\A:*.\x:A.x
t[id]
=t[\A:*.\x:A.x]
=\A:*.t[\x:A.x]
=\A:*.\x:A.t[x]
=\A:*.\x:A.A:*
\A:*.A->A

empty='[]':'List[Nat][0]'
append=\n:Nat.\l:'List[Nat][$n]'.\d:Nat.('[]'+'[$d]'):'List[Nat][$n+1]'
t[append]
=\n:Nat.\l:'List[Nat][$n]'.\d:Nat.'List[Nat][$n+1]'
=\n:Nat.'List[Nat][$n]'->Nat->'List[Nat][$n+1]'

------------
Tests

id=\A:*.\x:A.x
idNat=id Nat:*
idNat 2:Nat
Pair=\A:*.\B:*."Pair[$A][$B]"
pair=\A:*.\B:*.\a:A.\b:B.\f:A->B->(Pair A B).f a b
List=\A:*.\n:Nat."List[$A][$n]"
emptyList=\A:*."[]":(List A 0)

plus = \a:Nat.\b:Nat.{+ a b}:Nat
inc:(\x:Nat.Nat)

double=\A:*.\f:A->A.\a:A. f (f a)

double Nat:* inc 2:Nat

idd=\x:Nat. (\y:Nat.y) x
idd 2:Nat

let y=(\x:*.x:*) in (\x.2):y
(\x.x):Nat->Nat 2:Nat

------------

id=\A:*.\x:A.x
id Nat:*
(\A:*.\x:A.x) Nat:*
let A=Nat:* in \x:A:*.x
idNat=\x:Nat:*.x

idNat 2:Nat:*
(\x:Nat:*.x) 2:Nat:*
let x=2:Nat:* in x
2:Nat:*

t[id]
=\A:*.\x:A.t[x]
=\A:*.\x:A.A

t[t[id]]
t[\A:*.\x:A.A]
=\A:*.\x:A.*

idd 2:Nat
=(\x:Nat.(\y:Nat.y) x) 2:Nat
=let x=2:Nat in (\y:Nat.y) x
=(\y:Nat.y) 2:Nat
=let y=2:Nat in y
2:Nat

t[idd 2:Nat]
=t[(\x:Nat.(\y:Nat.y) x) 2:Nat]
=t[(\x:Nat.(\y:Nat.y) x)] 2:Nat
=(\x:Nat.t[(\y:Nat.y) x]) 2:Nat
=(\x:Nat.t[(\y:Nat.y)] x) 2:Nat
=(\x:Nat.(\y:Nat.t[y]) x) 2:Nat
=(\x:Nat.(\y:Nat.Nat:*) x) 2:Nat
=let x=2:Nat in (\y:Nat.Nat:*) x
=(\y:Nat.Nat:*) 2:Nat
=let y=2:Nat in Nat:*
=Nat:* 

e[idd 2:Nat]
=(\x.(\y.y) x) 2

((\x.(\y.y) x) 2):Nat
=((\y.y) 2):Nat
=2:Nat

---
Type of functions
T1 -> T2    === \x:T1:*.T2:*

universal types
Ax.x        ===  \x:*.x

dependent types
\n:Nat.'List[$n]':*  === same

t[\x:Nat:*.x]
=\x:Nat:*.Nat:*

t[\x:Nat:*.Nat:*]
=\x:Nat:*.*
e[\x:Nat:*.Nat:*]
=\x.Nat

o[(\x:Nat):(\x:Nat:*.*)]
=\x:Nat:*.o[Nat:*]
=\x:Nat:*.Nat:*

\b:Bool. if b then Nat:* else String:*
\b:Bool. if not b then String:* else Nat:*

(\x:(\x:C.D).b:B) (\x:C.d:D)
=(\x:(\x:C.D).b:B) (\x.d):(\x:C.D)
=let x=(\x.d):(\x:C.D) in b:B

---
# Kind and Types

$K ::=$ || *kinds:*
&nbsp;| $\star$ | *proper-kind*
&nbsp;| $\lambda x{:}T.K$ | *function-kind*
$T ::=$ || *well-formed types/keys:*
&nbsp;| $x$ | *variable*
&nbsp;| $b{:}\star$ | *proper-type*
&nbsp;| $\lambda x{:}T.e \quad\text{where }\tau[e]{\equiv}K$ | *function-type*
---

pair=\A:*.\B:*.\a:A.\b:B.\f:A->B->(Pair A B).f a b

id=\A:*.\x:A.x
=(\A.\x.x):(\A:*.\x:A.A)

id Nat:* 2:Nat:*
=(\A.\x.x):(\A:*.\x:A.A) Nat:* 2:Nat:*
=((\A.\x.x) Nat):((\A:*.\x:A.A) Nat:*) 2:Nat:*
=((\A.\x.x) Nat):(let A=Nat:* in \x:A.A) 2:Nat:*
=((\A.\x.x) Nat):(\x:Nat:*.Nat:*) 2:Nat:*
=((\A.\x.x) Nat 2):((\x:Nat:*.Nat:*) 2:Nat:*)
=((\A.\x.x) Nat 2):(let x=2:Nat:* in Nat:*)
=((\A.\x.x) Nat 2):(Nat:*)
=2:Nat:*

inc=(\x.{+1 x}):(\x:Nat:*.Nat:*)

inc 2:Nat:*
=(\x.{+1 x}):(\x:Nat:*.Nat:*) 2:Nat:*
=((\x.{+1 x}) 2):((\x:Nat:*.Nat:*) 2:Nat:*)
=((\x.{+1 x}) 2):(let x=2:Nat:* in Nat:*)
=((\x.{+1 x}) 2):Nat:*
={+1 2}:Nat:*
=3:Nat:*

-----
Even dependent type

-native-calls
isEven x = if x%2==0 then 'Even' else 'Odd'

typeNat=\x:Nat:*.{isEven x}:*

castNat=\x:Nat:*.x:(typeNat x)

typeNat 2:Nat:*
=(\x:Nat:*.{isEven x}:*) 2:Nat:*
=let x=2:Nat:* in {isEven x}:*
={isEven 2}:*
=Even:*

typeNat 3:Nat:*
=Odd:*


NatTypeCons=\x:Nat:*.*
NatTypeCons=\x:Nat:*.Even|Odd:*

zero=\f:Nat:*->Nat:*.\z:Nat:*. z
t[zero]
=\f:Nat:*->Nat:*.\z:Nat:*.Nat:*

Number=\f:Nat:*->Nat:*.\z:Nat:*.Nat:*

two=\f:Nat:*->Nat:*.\z:Nat:*. f (f z)
four=\f:Nat:*->Nat:*.\z:Nat:*. f (f (f (f z)))
add=\m:Number.\n:Number.\f:Nat->Nat.\z:Nat. m f (n f z)

add two
=add (\f:Nat:*->Nat:*.\z:Nat:*. f (f z))
=add (\f.\z.f (f z)):(\f:Nat:*->Nat:*.\z:Nat:*. Nat:*->Nat:* (Nat:*->Nat:* Nat:*))

Number === (\f:Nat:*->Nat:*.\z:Nat:*. Nat:*->Nat:* (Nat:*->Nat:* Nat:*))

(\x:Nat:*.x) 2:((\x:*.x) Nat:*)

Note: It was the bad idea to compare to dependent types. Because even they are equal, they can be evaluated to error.
In this case we should throw the error, instead of unlocking the expression.
Maybe I am wrong. What about compare error:* in unlock, but throw error in let-binding.

List=\n:Nat:*.'ListType[$n]':*
nil='[]':(List 0:Nat:*)
cons=\n:Nat:*.\head:Nat:*.\tail:(List n). {'cons' head tail}:(List {+ n 1}:Nat:*)

cons 0:Nat:* 2:Nat:* nil
=(\n:Nat:*.\head:Nat:*.\tail:(List n). {'cons' head tail}:(List {+ n 1}:Nat:*)) 0:Nat:* 2:Nat:* nil
=(let n=0:Nat:* in \head:Nat:*.\tail:(List n). {'cons' head tail}:(List {+ n 1}:Nat:*)) 2:Nat:* nil
=(\head:Nat:*.\tail:(List 0:Nat:*). {'cons' head tail}:(List {+ 0 1}:Nat:*)) 2:Nat:* nil
=(let head=2:Nat:* in \tail:(List 0:Nat:*). {'cons' head tail}:(List {+ 0 1}:Nat:*)) nil
=(\tail:(List 0:Nat:*). {'cons' 2  tail}:(List {+ 0 1}:Nat:*)) nil
=(\tail:((\n:Nat:*.'ListType[$n]':*) 0:Nat:*). {'cons' 2  tail}:(List {+ 0 1}:Nat:*)) nil
=(\tail:(let n=0:Nat:* in 'ListType[$n]':*). {'cons' 2 tail}:(List {+ 0 1}:Nat:*)) nil
=(\tail:'ListType[0]':*. {'cons' 2  tail}:(List {+ 0 1}:Nat:*)) nil
=(\tail:'ListType[0]':*. {'cons' 2  tail}:(List {+ 0 1}:Nat:*)) '[]':(List 0:Nat:*)
=(\tail:'ListType[0]':*. {'cons' 2  tail}:(List {+ 0 1}:Nat:*)) '[]':((\n:Nat:*.'ListType[$n]':*) 0:Nat:*)
=(\tail:'ListType[0]':*. {'cons' 2  tail}:(List {+ 0 1}:Nat:*)) '[]':(let n=0:Nat:* in 'ListType[$n]':*)
=(\tail:'ListType[0]':*. {'cons' 2  tail}:(List {+ 0 1}:Nat:*)) '[]':'ListType[0]':*
=let tail='[]':'ListType[0]':* in {'cons' 2  tail}:(List {+ 0 1}:Nat:*)
={'cons' 2 '[]'}:(List {+ 0 1}:Nat:*)
={'cons' 2 '[]'}:(List 1:Nat:*)
={'cons' 2 '[]'}:((\n:Nat:*.'ListType[$n]':*) 1:Nat:*)
={'cons' 2 '[]'}:(let n=1:Nat:* in 'ListType[$n]':*)
={'cons' 2 '[]'}:'ListType[1]':*
='[2]':'ListType[1]':*

t[cons 0:Nat:* 2:Nat:* nil]
=t[cons 0:Nat:* 2:Nat:*] nil
=t[cons 0:Nat:*] 2:Nat:* nil
=t[cons] 0:Nat:* 2:Nat:* nil
=t[\n:Nat:*.\head:Nat:*.\tail:(List n). {'cons' head tail}:(List {+ n 1}:Nat:*)] 0:Nat:* 2:Nat:* nil
=(\n:Nat:*.\head:Nat:*.\tail:(List n). t[{'cons' head tail}:(List {+ n 1}:Nat:*)]) 0:Nat:* 2:Nat:* nil
=(\n:Nat:*.\head:Nat:*.\tail:(List n). (List {+ n 1}:Nat:*)) 0:Nat:* 2:Nat:* nil
=(let n=0:Nat:* in \head:Nat:*.\tail:(List n). (List {+ n 1}:Nat:*)) 2:Nat:* nil
=(\head:Nat:*.\tail:(List n). (List {+ n 1}:Nat:*)) 2:Nat:* nil

In let-binding, I need to ignore bound variable if it is not used in the body of let-binding. This vay I will
ignore dependent type. So in let-binding ignores.
No, no, and NO. There should be 2 lock: with argument, without argument

With argument:
(\head:Nat:*.\tail:(List n). (List {+ n 1}:Nat:*)) 2:Nat:*
Without argument:
(Nat:*->\tail:(List n). (List {+ n 1}:Nat:*)) 2:Nat:*

Or in typing operator, I should unlock "unlock" expression when I see that argument is free in the body of lock.
But how can I unlock it without type checking.
I need a signal to determine the argument is needed or not.

(\x:(List 2).2:Nat:*) {+ 1 2}:(List 2)
=(\x:'List[2]':*.2:Nat:*) {+ 1 2}:'List[2]':*

(\x:Nat:*.5:Nat:*)  2:Nat:*

Nat:*->(5:Nat:*)  Nat:*
=5:Nat:*

(\x:Nat:*.x) 2:Nat:*
=Nat:*->(\x.x)  Nat:* 2
=(\x.x) 2

Nat:*->(\x.x):Nat:* Nat:* 2
=(\x.x):Nat:* 2
=2:Nat:*

Nat->Nat.(\x.x)  Nat 2
Nat (\x.x) 2
Nat 2

E1->t:E2 t:E3
if E1 == E2 then (t t):E2

E1->t:E2 E3
if E1 == E3 then t:E2

t:E2 t
(t t):E2

E->t1:E1 t2:E2
if E==E2 then (t1 t2):E1

E->E1.t1 t2:E2
if E==E2 then (t1 t2):E1

E->E1.t1 E2
if E==E2 then t1:E1

E->E1.\x.t1  t2:E2
E==E2 |- ((\x.t1) t2):E1

E->E1.t1  ->E2.t2
E==E2.->E1.(t1 t2)

E->E1.t1 ->E2
E==E2. ->E1.t1

id=Nat->Nat.\x.x

id ->Nat.2
=(Nat->Nat.\x.x) ->Nat.2
=->Nat.(\x.x) 2

id (id ->Nat.2)
=id ->Nat.((\x.x) 2)
=(Nat->Nat.\x.x) ->Nat.((\x.x) 2)
=->Nat.(\x.x) ((\x.x) 2)
=->Nat.(\x.x) 2
=->Nat.2

K->R.term

->R.term

id=Nat->Nat.(\x.x)

(\x:E1.e) t:E2
=let X=E1==E2 in let x:X in e

t[let X=E1==E2 in let x:X in e]
=let X=t[E1]==t[E2] in t[e]

t[(\x:E1.e) t:E2]
=let X=E1==E2 in (x:X |- t[e])

(\x:Nat:*.Nat:*)==(\x:Nat:*.Nat:*)
=\x:Nat:*.Nat:*==Nat:*
=\x:Nat:*.Nat:*

A=Nat:*

t[\x:A.x]

------

id=\A:*.\x:A.x

idNat = id Nat:*
=(\A:*.\x:A.x) Nat:*
=let A=Nat:* in \x:A.x
=\x:Nat:*.x

id idNat
=id e[idNat]:t[idNat]
=id (\x.x):(\x:Nat:*.Nat:*)
=(\A:*.\x:A.x) (\x:Nat:*.Nat:*) (\x.x):(\x:Nat:*.Nat:*)

??? any expression is considered as type
I am going to rollback syntax to t:t one insead of t:e syntax

Literal=\k:Nat. [String Nat]:* k
toString=\k:Nat.\v:(Literal k) [(v) ({str v}:String)] k

Literal 0:Nat
=(\k:Nat. [String Nat]:* k) 0:Nat
=let k=0:Nat in [String Nat]:* k
=[String Nat]:* 0:Nat
=String:*

stringToString=toString 0:Nat
=(\k:Nat.\v:(Literal k) [(v) ({str v}:String)] k) 0:Nat
=let k=0:Nat in \v:(Literal k) [(v) ({str v}:String)] k
=\v:(Literal 0:Nat) [(v) ({str v}:String)] 0:Nat
=\v:(Literal 0:Nat) [(v) ({str v}:String)] 0:Nat
=\v:String. [(v) ({str v}:String)] 0:Nat
=\v:String. v

t[toString 0:Nat]
=t[(\k:Nat.\v:(Literal k) [(v) ({str v}:String)] k) 0:Nat]
=let X=Nat==Nat in let k=0:X in t[\v:(Literal k) [(v) ({str v}:String)] k]
=let X=Nat==Nat in let k=0:X in \v:(Literal k).t[ [(v) ({str v}:String)] k]
=let X=Nat==Nat in let k=0:X in \v:(Literal k).t[ [t[(v)] ({str v}:String)] k]

t[id Nat->Nat:*]
=t[((\A:*.\x:A.x) Nat:*) Nat->Nat:*]
=let X=*==* in let A=Nat->Nat:X in t[\x:A.x]
=let X=*==* in let A=Nat->Nat:X in \x:A.t[x]
=let X=*==* in let A=Nat->Nat:X in \x:A.A:*
=let A=Nat->Nat:* in \x:A.A:*
=\x:Nat->Nat.Nat->Nat

-------

List=\n:Nat.{concat 'List' n}:*
nil='[]':'List0'
cons=\n:Nat.\head:String.let Tail=(List n) in \tail:Tail. let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result

list1 = cons 0:Nat 'hello':String nil
=(\n:Nat.\head:String.let Tail=(List n) in \tail:Tail. let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result) 0:Nat 'hello':String nil
=(let N={typeEqual Nat Nat}:* in let n=0:N in \head:String.let Tail=(List n) in \tail:Tail. let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result) 'hello':String nil
=(let N=Nat:* in let n=0:N in \head:String.let Tail=(List n) in \tail:Tail. let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result) 'hello':String nil
=(let n=0:Nat in \head:String.let Tail=(List n) in \tail:Tail. let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result) 'hello':String nil
=(\head:String.let Tail=(List 0:Nat) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' head tail}:Result) 'hello':String nil
=(let Head={typeEqual String String}:* in let head='hello':Head in let Tail=(List 0:Nat) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' head tail}:Result) nil
=(let Head=String:* in let head='hello':Head in let Tail=(List 0:Nat) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' head tail}:Result) nil
=(let head='hello':String in let Tail=(List 0:Nat) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' head tail}:Result) nil
=(let Tail=(List 0:Nat) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result) nil
=(let Tail=((\n:Nat.{concat 'List' n}:*) 0:Nat) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result) nil
=(let Tail=(let N={typeEqual Nat Nat}:* in let n:N in {concat 'List' n}:*) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result) nil
=(let Tail=(let N=Nat:* in let n:N in {concat 'List' n}:*) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result) nil
=(let Tail=(let n=0:Nat in {concat 'List' n}:*) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result) nil
=(let Tail=({concat 'List' 0}:*) in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result) nil
=(let Tail='List0':* in \tail:Tail. let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result) nil
=(\tail:'List0'. let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result) '[]':'List0'
=let Tail={typeEqual 'List0' 'List0'}:* in let tail='[]':Tail in let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result
=let Tail='List0':* in let tail='[]':Tail in let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result
=let tail='[]':'List0' in let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' tail}:Result
=let Result=(List {+ 0 1}:Nat) in {'cons' 'hello' '[]'}:Result
=let Result=(List 1:Nat) in {'cons' 'hello' '[]'}:Result
=let Result=((\n:Nat.{concat 'List' n}:*) 1:Nat) in {'cons' 'hello' '[]'}:Result
=let Result=(let N={typeEqual Nat Nat}:* in let n=1:N in {concat 'List' n}:*) in {'cons' 'hello' '[]'}:Result
=let Result=(let N=Nat:* in let n=1:N in {concat 'List' n}:*) in {'cons' 'hello' '[]'}:Result
=let Result=(let n=1:Nat in {concat 'List' n}:*) in {'cons' 'hello' '[]'}:Result
=let Result=({concat 'List' 1}:*) in {'cons' 'hello' '[]'}:Result
=let Result='List1':* in {'cons' 'hello' '[]'}:Result
={'cons' 'hello' '[]'}:'List1'
='["hello"]':'List1'

e[cons 0:Nat 'hello':String nil]
=e[cons] e[0:Nat] e['hello':String] e[nil]
=e[\n:Nat.\head:String.let Tail=(List n) in \tail:Tail. let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result] 0 'hello' e['[]':'List0']
=(\n.\head.(\Tail.e[\tail:Tail. let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result]) e[List n]) 0 'hello' '[]
=(\n.\head.(\Tail.\tail. e[let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result]) e[(\n:Nat.{concat 'List' n}:*) n]) 0 'hello' '[]
=(\n.\head.(\Tail.\tail. (\Result.{'cons' head tail}) (List {+ n 1}:Nat) e[let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result]) e[(\n:Nat.{concat 'List' n}:*) n]) 0 'hello' '[]

t[cons 0:Nat 'hello':String nil]
=t[(\n:Nat.\head:String.let Tail=(List n) in \tail:Tail. let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result) 0:Nat 'hello':String nil]
=(let N={typeEqual Nat Nat} in let n=0:N in \head:String.let Tail=(List n) in \tail:Tail. let Result=(List {+ n 1}:Nat) in {'cons' head tail}:Result) 'hello':String nil

sum=\a:Nat.\b:Nat.{plus a b}:Nat

sum 2:Nat 3:Nat
=(\a:Nat.\b:Nat.{plus a b}:Nat) 2:Nat 3:Nat
=(let A={= Nat Nat}:* in let n=2:N in \b:Nat.{plus a b}:Nat) 3:Nat
=(let A=Nat:* in let n=2:N in \b:Nat.{plus a b}:Nat) 3:Nat
=(let n=2:Nat in \b:Nat.{plus a b}:Nat) 3:Nat
=(\b:Nat.{plus 2 b}:Nat) 3:Nat
=let B={= Nat Nat}:* in let b=3:B in {plus 2 b}:Nat
=let B=Nat:* in let b=3:B in {plus 2 b}:Nat
=let b=3:Nat in {plus 2 b}:Nat
={plus 2 3}:Nat
=5:Nat

e[sum 2:Nat 3:Nat]
=e[sum] e[2:Nat] e[3:Nat]
=e[(\a:Nat.\b:Nat.{plus a b}:Nat) 2:Nat 3:Nat] 2 3
=(\a.\b.{plus a b}) 2 3

t[sum]
=t[(\a:Nat.\b:Nat.{plus a b}:Nat)]
=let R=t[{plus a b}:Nat] in Nat->Nat->R:*
=let R=Nat in Nat->Nat->R:*
=Nat->Nat->Nat:*
=\a:Nat.b:Nat.Nat:*

t[sum 2:Nat]
=(\a:Nat. sum a) 2:Nat
=let a=2:Nat in t[sum] a
=let a=2:Nat in Nat->Nat->Nat:* a

List=\n:Nat.{concat 'List' n}:*
t[\n:Nat.{concat 'List' n}:*]
=\n:Nat.*:*

??? Now I recall that why I chose t:e syntax. For making dependent type as parameter to function

id=\A:*.\x:A.x
t[id]=\A:*.\x:A.A
e[id]=\A.\x.x

(id t[id] id) == id

id t[id]
=(\A:*.\x:A.x) (\A:*.\x:A.A)
=\x:(\A:*.\x:A.A).x

(\x:(\A:*.\x:A.A).x) (\A.\x.x):(\A:*.\x:A.A)
=let X=(\A:*.\x:A.A)==(\A:*.\x:A.A) in let x=(\A.\x.x):X in x
=let X=(\A:*.\x:A.A==A) in let x=(\A.\x.x):X in x
=let X=(\A:*.\x:A.A) in let x=(\A.\x.x):X in x
=let x=(\A.\x.x):(\A:*.\x:A.A) in x
=(\A.\x.x):(\A:*.\x:A.A)

f[(\A.\x.x):(\A:*.\x:A.A)]
=\A:*.f[(\x.x):(\x:A.A)]
=\A:*.\x:A.f[(x):(A)]
=\A:*.\x:A.let X=t[x]==A in x
=\A:*.\x:A.let X=A==A in x
=\A:*.\x:A.let X=A in x
=\A:*.\x:A.x

id t[id]
=(\A:*1.\x:A.x) (\A:*0.\x:A.A)

------
How to reduce dependent type of lock's parameter???

q=\n:Nat. "[0^n]":"List[$n]"
D=t[q]=\n:Nat. "List[$n]":*

r=\n:Nat. "[1^n]":"List[$n]"
D=t[r]=\n:Nat. "List[$n]":*

s=\d:D.\n:Nat. d n
t[s]
=\d:D.\n:Nat. t[d] n
=\d:D.\n:Nat. D n

s q 2
=(\d:D.\n:Nat. d n) (\n."[0^n]"):D
=let X=D1==D2 in let d:X in \n:Nat. d n
=(let d=D1 in \n:Nat. d n)==(let d=D2 in \n:Nat. d n)
=(\n:Nat. D1 n)==(\n:Nat. D2 n)

(\n:Nat. D1 n)==(\n:Nat. D2 n) 2:Nat
((\n:Nat. D1 n) 2:Nat)==((\n:Nat. D2 n) 2:Nat)
(let n=2:Nat in D1 n)==(let=n2:Nat in D2 n)
(D1 2:Nat)==(D2 2:Nat)

s q 2
=(\d:D1.\n:Nat. d n) (\n."[0^n]"):D2
=let X=D1==D2 in let d=(\n."[0^n]"):X in \n:Nat.d n
=(\d.\n.d n):(let d=D1 in \n:Nat.d n)==(let d=D1 in \n:Nat.d n)

idNat=:Nat.\x.x

idNat 2:Nat
=:Nat.\x.x 2:Nat
=let x=2:Nat=Nat in x

id=\A.:A.\x.x

id Nat 3:Nat
=(\A.:A.\x.x) Nat 3:Nat
=:Nat.\x.x 3:Nat
=let x=3:Nat=Nat in x
=let x=3:Nat in x
3:Nat

const=:Nat.3:Nat

just unlocking
const :Nat
=(:Nat.3:Nat) :Nat
=let R=Nat=Nat in 3:Nat

t[id]
=\A.:A.\x.A

const=\:Nat.3:Nat

id2=\a:Nat.(\b:Nat.b) a

t[id2]
=\a:Nat. let b=a==Nat in t[b]

t[(\b:Nat.b) a:Nat]
=t[let b=a:Nat in b]
=let b=Nat:* in b
=Nat:*

t[a b]
=t[a] b

id=\A:*.\x:A.x
t[id]=\A:*.\x:A.A=\A:*.A->A

Nat->Nat {+ 2 3}:Nat
let R=Nat==Nat in Nat

\_:Nat.Nat {+ 2 4}:Nat
=let _=Nat==Nat in Nat

\x:Nat.Nat {+ 2 4}:Nat
=let x={+ 2 4}:Nat in Nat

t[\a:Nat.(\b:Nat.b) a]
=\a:Nat.t[(\b:Nat.b) a]
=\a:Nat.t[(\b:Nat.b)] a
=\a:Nat.(\b:Nat.t[b]) a
=\a:Nat.(\:Nat.Nat) a
=\a:Nat.let _=Nat==Nat in Nat
=\a:Nat.let _=Nat in Nat
=\a:Nat.Nat

\:Nat.Nat

???
let x=(\:Nat.Nat)==(\:Nat.String) in x 2:Nat
=let x=\:Nat.Nat==String in x 2:Nat
=let x=\:Nat.error:* in x 2:Nat

let x=(\x:Nat.Nat)==(\x:Nat.String) in x 2:Nat
(\x:Nat.Nat 2:Nat)==(\x:Nat.String 2:Nat)

\a:Nat.(\b:Nat.b) a
=\a:Nat. let b=e[a]:t[a]==Nat in b
=\a:Nat. let b=a:Nat==Nat in b
=\a:Nat. let b=a:Nat in b
=\a:Nat. a:Nat

q=let r=(\x:Nat.Nat)==(\x:Nat.Nat) in r
e[q]=(\r.r)==(\r.r) in r

id=\x:Nat.x
e[id]=\x.x
t[id]=\:Nat.Nat
apply=\f:(\:Nat.Nat).\a:Nat. f a
e[apply]=\f.\a.f a
t[apply]=\:(\:Nat.Nat).\:Nat. (\:Nat.Nat) :Nat

(\:Nat.Nat) :Nat
=let R=Nat==Nat in Nat
=Nat

let x=Nat:*==Nat:* in 3:Nat    ((\x.3) Nat):(let x=*==* in Nat)
=let x=Nat:* in 3:Nat          ((\x.3) Nat):(let x=* in Nat)
=3:Nat

(\x:Nat:*.3:Nat:*) 'hello':String:*                 ((\x.3) 'hello'):((\:Nat:*.Nat:*) 'hello':String:*)
=let x='hello':(String:* == Nat:*) in 3:Nat:*       ((\x.3) 'hello'):(let r=String:*==Nat:* in Nat:*)
=let x='hello':error:* in 3:Nat:*                   ((\x.3) 'hello'):(let r=error:* in Nat:*)
=let x=error:* in 3:Nat:*                           ((\x.3) 'hello'):error:*
=error:*                                            error:*

(\:Nat:*.Nat:*) 'hello':String:*                    (Nat):((\:Nat:*.*) 'hello':String:*)
=let a=String:*==Nat:* in Nat:*                     (Nat):(let a=* in *)

(\:Nat:*.String:*) 3:Nat:*
=let q=Nat:*==Nat:* in 

q=(\a:Nat.\b:Nat. {concat a b}:String) 3:Nat 4:Nat
=let a=3:Nat==Nat in let b=4:Nat==Nat in {concat a b}:String
="34":String

e[q]
=(\a.\b.{concat a b}) 3 4
t[q]
=(\:Nat.\:Nat.String) 3:Nat 4:Nat
=let a=Nat==Nat in let b=Nat==Nat in String
=String

e[t[q]]
=e[(\:Nat.\:Nat.String) 3:Nat 4:Nat]
=\.\.String 3 4
t[t[q]]
=t[(\:Nat.\:Nat.String) 3:Nat 4:Nat]
=\:Nat.\:Nat.* 3:Nat 4:Nat
let R=Nat==Nat in let Q=Nat==Nat in *

q=\x:Nat.{toString x}:String
q 3:Nat
=(\x:Nat.{toString x}:String) 3:Nat
=let x=3:Nat==Nat in {toString x}:String
=let x=3:Nat in {toString x}:String
={toString 3}:String
='3':String

e[q 3:Nat]:t[q 3:Nat]
=((\x.{toString x}) 3):((\:Nat.String) 3:Nat)
=((\x.{toString x}) 3):(let r=Nat==Nat in String)
=((\x.{toString x}) 3):(let r=Nat in String)
=((\x.{toString x}) 3):String
={toString 3}:String
='3':String

r=((\:Nat:*.String:*) 3:Nat:*)
e[r]:t[r]
=((\.String) 3):((\:Nat:*.*) 3:Nat:*)
=((\.String) 3):(let _=Nat:*==Nat:* in *)
=((\.String) 3):(let _=Nat:* in *)
=((\.String) 3):*
=String:*

=(\:Nat:*.String:*) 3:Nat:*
=let _=Nat:*==Nat:* in String:*
=let _=*==* in *

t1:E1==t2:E2
(t1==t2):(E1==E2)
(\x.t2) t1=t2

(\x.Nat)==(\x.Str)
=\x.Nat==Str
=\x.error
=error

(\a:A.e) b:B
=A==B;let a=b:A in e

??? test
(\f:(\n:Nat. {+ {* 2 n} 10}:*).\a:Nat. f a) (\n. {* n 7}):(\n:Nat. {* 2 {+ n 5}}:*)
=let f=(\n. {* n 7}):(\n:Nat. ({+ {* 2 n} 10}=={* 2 {+ n 5}}):*) in \a:Nat. f a

t[^]
=\a:Nat. (\n:Nat. ({+ {* 2 n} 10}=={* 2 {+ n 5}}):*) a
=\a:Nat. ({+ {* 2 a} 10}=={* 2 {+ a 5}}):*

(\f:(\n:Nat. {2n+10}:*). f 3:Nat) (\n. {7n}):(\n:Nat. {2(n+5)}:*)
=let f=(\n. {7n}):(\n:Nat. {2(n+5)}:*)==(\n:Nat. {2n+10}:*) in f 3:Nat
=let f=(\n. {7n}):(\n:Nat. ({2(n+5)}=={2n+10}):*) in f 3:Nat
=((\f. f 3) (\n. {7n})):((\n:Nat. ({2(n+5)}=={2n+10}):*) 3:Nat)
=((\f. f 3) (\n. {7n})):(let n=3:Nat==Nat in ({2(n+5)}=={2n+10}):*)
=((\f. f 3) (\n. {7n})):(let n=3:Nat in ({2(n+5)}=={2n+10}):*)
=((\f. f 3) (\n. {7n})):({2(3+5)}=={2*3+10}):*
=((\f. f 3) (\n. {7n})):(16==16):*
=((\f. f 3) (\n. {7n})):16:*
=((\n. {7n}) 3):16:*
={7*3}:16:*
=21:16:*

q=(\f:(\n:Nat. {2n+10}:*). f 3:Nat)
=e[q]:t[q]
=(\f.f 3):(\f:(\n:Nat. {2n+10}:*). t[f] 3:Nat)
=(\f.f 3):(\:(\n:Nat. {2n+10}:*). (\n:Nat. {2n+10}:*) 3:Nat)
=(\f.f 3):(\:(\n:Nat. {2n+10}:*). 16:*)


(\a:Nat.Nat:*)==(\b:Nat.String:*)
\a:Nat.Nat==String:*
\a:Nat. error:*

(\f:(\n:Nat. {2n+10}:*). f 3:Nat) (\n. {7n}):(\n:Nat. {2(n+5)}:*)
=let f=(\n. {7n}):(\n:Nat. {2(n+5)}:*)==(\n:Nat. {2n+10}:*) in f 3:Nat
=e[^]:t[^]
=((\f.f 3) (\n. {7n})):t[f 3:Nat]
=((\f.f 3) (\n. {7n})):(t[f] 3:Nat)
=((\f.f 3) (\n. {7n})):((\n:Nat. {2(n+5)}:*)==(\n:Nat. {2n+10}:*) 3:Nat)
=((\f.f 3) (\n. {7n})):((\n:Nat. {2(n+5)}:*) 3:Nat)==((\n:Nat. {2n+10}:*) 3:Nat)
=((\f.f 3) (\n. {7n})):(let n=3:Nat==Nat in {2(n+5)}:*)==(let n=3:Nat==Nat in {2n+10}:*)
=((\f.f 3) (\n. {7n})):({2(3+5)}:*)==({2*3+10}:*)
=((\f.f 3) (\n. {7n})):(16:*)==(16:*)
=((\f.f 3) (\n. {7n})):16:*

??? test
(\f:(\:Nat:*.String:*). f 3:Nat) (\n.n):(\:Nat.Nat:*)
=let f=(\n.n):(\:Nat.Nat:*)==(\:Nat:*.String:*) in f 3:Nat
=let f=(\n.n):(\:Nat.Nat==String:*) in f 3:Nat
=let f=(\n.n):(\:Nat.error:*) in f 3:Nat
=let f=(\n.n):error:* in f 3:Nat
=let f=error:* in f 3:Nat
=error:*

t[\f:(\n:Nat. {2n+10}:*). f 3:Nat]
=\f:(\n:Nat. {2n+10}:*). (\n:Nat. {2n+10}:*) 3:Nat
=\f:(\n:Nat. {2n+10}:*). let n=3:Nat==Nat in {2n+10}:*
=\f:(\n:Nat. {2n+10}:*). {2*3+10}:*
=\f:(\n:Nat. {2n+10}:*). 16:*

let f=(\n:Nat. {2(n+5)}:*)==(\n:Nat. {2n+10}:*) in f
=((\f.f) (\n. {2(n+5)})==(\n. {2n+10})):t[(\n:Nat. {2(n+5)}:*)==(\n:Nat. {2n+10}:*)]
=((\f.f) (\n. {2(n+5)})==(\n. {2n+10})):(\n:Nat. *)==(\n:Nat. *)
=((\f.f) (\n. {2(n+5)})==(\n. {2n+10})):(\n:Nat. *)

(\n:Nat. {2(n+5)}:*)==(\n:Nat. {2n+10}:*)
=\n:Nat. ({2(n+5)}=={2n+10}):*
=(\n.({2(n+5)}=={2n+10})):(\n:Nat.*)

??? test
id=\x:Nat.x
t[id]=\:Nat.Nat
id2=\x:Nat. id x
t[id2]
=t[\x:Nat. id x]
=\x:Nat. t[id] x
=\x:Nat. \:Nat.Nat x

??? Test
NAT=Nat:*
SUCC=\z:NAT.NAT
NUMBER=\s:SUCC.\z:NAT.NAT
one=\s:SUCC.\z:NAT. s z
two=\s:SUCC.\z:NAT. s (s z)
four=\s:SUCC.\z:NAT. s (s (s (s z)))

one
=\s:SUCC.\z:NAT. s z
=\s:SUCC.\z:NAT. (s z):(SUCC _:NAT)
=\s:SUCC.\z:NAT. (s z):NAT
=\s:SUCC.(\z.(s z)):\z:NAT.NAT
=\s.(\z.(s z)):\s:SUCC.\z:NAT.NAT

add
=\m:NUMBER.\n:NUMBER.\s:SUCC.\z:NAT. m f (n f z)
=\m:NUMBER.\n:NUMBER.\s:SUCC.\z:NAT. m f ((n f):(NUMBER _:SUCC) z)

id=\A:*.\x:A.x
=(\A.\x.x):(\A:*.\x:A.A)
=(\A.\x.x):(\A.\x.A):(\A:*.\x:A.*)

id Nat:*
=(\A.\x.x):(\A.\x.A):(\A:*.\x:A.*) Nat:*
=let z=Nat:* in ((\A.\x.x) z):((\A.\x.A) z):((\A:*.\x:A.*) z)
=((\A.\x.x) Nat):((\A.\x.A) Nat):((\A:*.\x:A.*) Nat:*)
=((\A.\x.x) Nat):((\A.\x.A) Nat):(let A=Nat:*==* in \x:A.*)
=((\A.\x.x) Nat):((\A.\x.A) Nat):(let A=Nat:* in \x:A.*)
=((\A.\x.x) Nat):((\A.\x.A) Nat):(\x:Nat:*.*)
=((\A.\x.x) Nat):(\x.Nat):(\x:Nat:*.*)

(\s:Nat:*. {+ 2 s}:{toString s}:*) 3:Nat:*
=(\s.{+ 2 s}):(\s:Nat:*.{toString s}:*) 3:Nat:*
=(\s.{+ 2 s}):(\s.{toString s}):(\s:Nat:*.*) 3:Nat:*
=let R=((\s:Nat:*.*) _:Nat:*) in let s=3:Nat:* in {+ 2 s}:{toString s}:R
=let R=((\s:Nat:*.*) _:Nat:*) in let s=3:Nat:* in {+ 2 s}:{toString s}:R

(\s:Nat:*. {+ 2 s}:{toString s}:*) 3:Nat:*
=let s=3:Nat:*==Nat:* in {+ 2 s}:{toString s}:*
=let s=3:Nat:* in {+ 2 s}:{toString s}:*
={+ 2 3}:{toString 3}:*
={+ 2 3}:"3":*
=5:"3":*

q=(\s:Nat:*. {+ 2 s}:{toString s}:*) {+ 5 7}:Nat:*
=e[q]:t[q]
=((\s. {+ 2 s}) {+ 5 7}):((\s:Nat:*. {toString s}:*) {+ 5 7}:Nat:*)
=let x={+ 5 7}:Nat:* in ((\s. {+ 2 s}) x):((\s:Nat:*. {toString s}:*) x)

One way to make dependent type argument as lazy is to implement store, and replace the term with store label.

f=a1:a2:a3:b1:b2:b3 c1:c2:c3:c4
=let R=(b1:b2:b3 _:c2:c3:c4) in let r=c1:c2:c3:c4 in (a1 r):(a2 r):(a3 r):R

str=\n:Nat:*. {toString n}:String:*
=(\n.{toString n}):(\n:Nat:*.String:*)

str 3:Nat:*
=(\n.{toString n}):(\n:Nat:*.String:*) 3:Nat:*
=let R=((\n:Nat:*.String:*) _:Nat:*) in let x=3:Nat:* in ((\n.{toString n}) x):R
=let R=String:* in let x=3:Nat:* in ((\n.{toString n}) x):R
=let x=3:Nat:* in ((\n.{toString n}) x):String:*
=((\n.{toString n}) 3):String:*
={toString 3}:String:*
="3":String:*

dt=\s:Nat. {+ 2 s}:{toString s}
=\s:Nat. {+ 2 s}:{toString s}:*
=(\s.{+ 2 s}):(\s:Nat. {toString s}:*)
=(\s.{+ 2 s}):(\s. {toString s}):(\s:Nat.*)

n===s
dt 3:Nat:*
=(\n.{+ 2 s}):(\n. {toString s}):(\n:Nat.*) 3:Nat:*
=let R=((\n:Nat.*) _:Nat:*) in let r=3:Nat:* in ((\n.{+ 2 s}) r):((\n. {toString s}) r):R
=let R=* in let r=3:Nat:* in ((\n.{+ 2 s}) r):((\n. {toString s}) r):R
=let r=3:Nat:* in ((\n.{+ 2 s}) r):((\n. {toString s}) r):*
=((\n.{+ 2 s}) 3):((\n. {toString s}) 3):*
=((\n.{+ 2 s}) 3):({toString 3}):*
=((\n.{+ 2 s}) 3):"3":*
={+ 2 3}:"3":*
=5:"3":*

dt2=(\a:Nat. dt a)
=(\a:Nat. (\s.{+ 2 s}):(\s. {toString s}):(\s:Nat.*) a)
=(\a:Nat. let R=((\s:Nat.*) _:Nat) in let r=a in ((\s.{+ 2 s}) r):((\s. {toString s}) r):R)
=(\a:Nat. let R=* in let r=a in ((\s.{+ 2 s}) r):((\s. {toString s}) r):R)
=(\a:Nat. let r=a in ((\s.{+ 2 s}) r):((\s. {toString s}) r):*)
=(\a:Nat. ((\s.{+ 2 s}) a):((\s. {toString s}) a):*)
=(\a:Nat. {+ 2 a}:{toString a}:*)
=(\a.{+ 2 a}):(\a:Nat. {toString a}:*)
=(\a.{+ 2 a}):(\a. {toString a}):(\a:Nat. *)

Succ=\z:Nat.Nat
Number=\s:Succ.\z:Nat.Nat

add
=\m:Number.\n:Number.\s:Succ.\z:Nat. (m s) ((n s) z)
=\m:Number.\n:Number.\s:Succ.\z:Nat. (let R=(Number _:Succ) in let r=s in (m r):R) ((n s) z)
=\m:Number.\n:Number.\s:Succ.\z:Nat. (let R=Succ in let r=s in (m r):R) ((n s) z)
=\m:Number.\n:Number.\s:Succ.\z:Nat. (let r=s in (m r):Succ) ((n s) z)
=\m:Number.\n:Number.\s:Succ.\z:Nat. ((\r.(m r)) s):Succ ((n s) z)
=\m:Number.\n:Number.\s:Succ.\z:Nat. (m s):Succ ((n s) z)
=\m:Number.\n:Number.\s:Succ.\z:Nat. (m s):Succ ((n s):Succ z)
=\m:Number.\n:Number.\s:Succ.\z:Nat. (m s):Succ (let R=(Succ _:Nat) in let r=z in ((n s) r):R)
=\m:Number.\n:Number.\s:Succ.\z:Nat. (m s):Succ (let R=Nat in let r=z in ((n s) r):R)
=\m:Number.\n:Number.\s:Succ.\z:Nat. (m s):Succ (let r=z in ((n s) r):Nat)
=\m:Number.\n:Number.\s:Succ.\z:Nat. (m s):Succ ((n s) z):Nat
=\m:Number.\n:Number.\s:Succ.\z:Nat. let R=(Succ _:Nat) in let r=((n s) z):Nat in ((m s) r):R
=\m:Number.\n:Number.\s:Succ.\z:Nat. let R=Nat in let r=((n s) z):Nat in ((m s) r):R
=\m:Number.\n:Number.\s:Succ.\z:Nat. let r=((n s) z):Nat in ((m s) r):Nat
=\m:Number.\n:Number.\s:Succ.\z:Nat. ((\r.((m s) r)) ((n s) z)):Nat
=\m:Number.\n:Number.\s:Succ.\z:Nat. ((m s) ((n s) z)):Nat
=\m:Number.\n:Number.\s:Succ.(\z.((m s) ((n s) z))):\z:Nat.Nat
=\m:Number.\n:Number.\s.\z.((m s) ((n s) z)):\s:Succ.\z:Nat.Nat
=\m:Number.\n.\s.\z.((m s) ((n s) z)):\n:Number.\s:Succ.\z:Nat.Nat
=\m.\n.\s.\z.((m s) ((n s) z)):\m:Number.\n:Number.\s:Succ.\z:Nat.Nat


TODO: what happens here \a:Nat. let r=(n s) in ((\s.{+ 2 s}) r):((\s. {toString s}) r):*

let r=a1:a2:b1:b2 in (c1 r):(c2 r):d1:d2
= a2 -> r=a1 -> c2 r -> c1 r
= (a2; (\r. (c2 r);(c1 r)) a1):d1:d2

f=a1:a2:a3:a4 c1:c2:c3:c4
=(a1 c1):(a2 'c1):(a3 'c1):(a4 'c1:c2:c3:c4)

dt=\s:Nat:*. {+ 2 s}:{toString s}:*
=(\s.{+ 2 s}):(\s:Nat. {+ 2 s}:{toString s}:*)

(\s.{+ 2 s}):(\s:Nat. {+ 2 s}:{toString s}:*) {+ 4 5}:Nat
=((\s.{+ 2 s}) L1[{+ 4 5}]):((\s:Nat. {toString s}:*) L1:Nat)
=((\s.{+ 2 s}) L1[{+ 4 5}]):(let s=L1:Nat==Nat in {toString s}:*)
=((\s.{+ 2 s}) L1[{+ 4 5}]):(let s=L1:Nat in {toString s}:*)
=((\s.{+ 2 s}) L1[{+ 4 5}]):({toString L1}:*)
=((\s.{+ 2 s}) L1[9]):({toString L1}:*)
=((\s.{+ 2 s}) 9):({toString 9}:*)
=((\s.{+ 2 s}) 9):"9":*
={+ 2 9}:"9":*
=11:"9":*

process=\a:Request:*.{getName a}:{getResponseType a}:*
e[process]=\a.{getName a}
t1[process]=\a:Request:*.{getResponseType a}:*
t2[process]=\_:Request:*.*

handle=\r:Request:*. process r
=\r:Request:*. (\a:Request:*.{getName a}:{getResponseType a}:*) r
=\r:Request:*. let a=r:(Request:*==Request:*) in {getName a}:{getResponseType a}:*
=\r:Request:*. let a=r:Request:* in {getName a}:{getResponseType a}:*
=\r:Request:*. {getName r}:{getResponseType r}:*
=(\r.{getName r}):(\r:Request:*.{getResponseType r}:*)
=(\r.{getName r}):(\r.{getResponseType r}):(\_:Request.*)

handle 'name:alpha type:beta':Request:*
=((\r.{getName r}):(\r.{getResponseType r}):(\_:Request.*)) 'name:alpha type:beta':Request:*
='alpha':'beta':*

(\x.a):(\x.b):(\_:Nat.*) 5:Nat:*
=((\x.a) 5):((\x.b):(\_:Nat.*) 5:Nat:*)
=((\x.a) 5):((\x.b) 5):((\_:Nat.*) 5:Nat:*)
=((\x.a) 5):((\x.b) 5):(let _=5:(Nat:*==Nat:*) in *)
=((\x.a) 5):((\x.b) 5):(let _=5:Nat:* in *)
=((\x.a) 5):((\x.b) 5):*
=((\x.a) 5):b:*
=a:b:*


id=\A:*.\x:A.x
=(\_.\x.x):(\A:*.\x:A.A)
=(\_.\x.x):(\A.\x.A):(\A:*.\x:A.*)

q=\x:Nat. (\a:Nat.\b:Nat. a:b) x x
=(\x.(\a.\b.a) x x):(\x:Nat. (\_:Nat.\b:Nat. b) x x)
=(\x.(\a.\b.a) x x):(\x:Nat. x)
=(\x.x):(\x.x):(\_:Nat. Nat)

q 3:Nat
=(\x.x):(\x.x):(\_:Nat. Nat) 3:Nat
=((\x.x) 3):((\x.x):(\_:Nat. Nat) 3:Nat)
=((\x.x) 3):((\x.x) 3):((\_:Nat. Nat) 3:Nat)
=((\x.x) 3):((\x.x) 3):(let L=Nat==Nat in Nat)
=((\x.x) 3):((\x.x) 3):Nat
=3:3:Nat

q=\\x:Nat:*.x:x
=(\x.x):(\x:Nat:*.x)
=(\x.x):(\x.x):(_:Nat:*.Nat:*)

q 3:Nat:*
=(\\x:Nat:*.x:x) 3:Nat:*
=let U=Nat:*==Nat:* in let x=3:U in x:x
=let U=Nat:* in let x=3:U in x:x
=let x=3:Nat:* in x:x
=3:3:Nat:*

=(\x.x):(\x.x):(_:Nat:*.Nat:*) 3:Nat:*
=((\x.x) 3):((\x.x) 3):((_:Nat:*.Nat:*) 3:Nat:*)
=((\x.x) 3):((\x.x) 3):(let U=Nat:*==Nat:* in Nat:*)
=((\x.x) 3):((\x.x) 3):(let U=Nat:* in Nat:*)
=((\x.x) 3):((\x.x) 3):Nat:*
=3:3:Nat:*

s=q {+ 1 2}:Nat:*
=(\x.x):(\x.x):(_:Nat:*.Nat:*) {+ 1 2}:Nat:*
=A:B:C D:E
# (C E) -> y=D -> (B y) -> (A y)
=let U=Nat:*==Nat:* in let y={+ 1 2}:U in ((\x.x) y):((\x.x) y):Nat:*

e[s]
=(\y.(\x.x) y) {+ 1 2}
t[s]
=

(\x:Nat:*.x:x) t:Nat:*
=(\x.x):(\x.x):(_:Nat:*.Nat:*) t:Nat:*∏
=((\x.x) t):((\x.x) t):((_:Nat:*.Nat:*) t:Nat:*)
=((\x.x) t):((\x.x) t):(let U=Nat:* <? Nat:* in Nat:*)
=((\x.x) t):((\x.x) t):(let U=Nat:* in Nat:*)
=((\x.x) t):((\x.x) t):Nat:*


t={+ 1 2}
(\x:3:Nat:*.x) ((\x.x) t):((\x.x) t):Nat:*
=let U=3:Nat:*<?((\x.x) t):Nat:* in let x=((\x.x) t):U in x
or
=(\x.x):(_:3:Nat:*.3:Nat:*) ((\x.x) t):((\x.x) t):Nat:*
=((\x.x) ((\x.x) t)):((_:3:Nat:*.3:Nat:*) ((\x.x) t):((\x.x) t):Nat:*)
=((\x.x) ((\x.x) t)):(let U=3:Nat:*<?((\x.x) t):Nat:* in 3:Nat:*)

0x.t --> _.t
1x.t --> \x.t

0x:A.b:B:C -->  (_.t):(_:A.B:C)
1x:A.b:B:C --> (\x.t):(_:A.B:C)
2x:A.b:B:C -->  (_.t):(\x:A.B:C) --> (_.t):(\x.B):(_:A.C)
3x:A.b:B:C --> (\x.t):(\x:A.B:C) --> (\x.t):(\x.B):(_:A.C)
4x:A.b:B:C:D --> (_.t):(_.B):(\x:A.C:D) --> (_.t):(_.B):(\x.C):(_:A.D)
5x:A.b:B:C:D --> (\x.t):(_.B):(\x:A.C:D) --> (\x.t):(_.B):(\x.C):(_:A.D)

2x:A.b:B:C:D t:E
=let 2x=t:A==E in b:B:C:D
=((0x.b) t):(let 1x=t:A=E in B:C:D)
=((0x.b) t):((1x.B) t):(let 0x=t:A=E in C:D)
=((0x.b) t):((1x.B) t):()

2A:*. (1x:A.x) t:E
=2A:*. let 1x=t:E==A in x
=2A:*. ((1x.x) t):(let 1x=E==A in x)

first=1d:Vec2:*.{get 0 d}:Int:*
=(1d.{get 0 d}):(0d:Vec2.Int:*)
parse=3x:Raw.{toVec2 x}:{toVec2Type x}:*
=(1x.{toVec2 x}):(1x.{toVec2Type x}):(0x:Raw.*)
parseAndFirst=3b:Raw.first (parse b)
=3b:Raw.first ((1x.{toVec2 x}):(1x.{toVec2Type x}):(0x:Raw.*) b)
=3b:Raw.first ((1x.{toVec2 x}) b):((1x.{toVec2Type x}) b):((0x:Raw.*) b)
=3b:Raw.first ((1x.{toVec2 x}) b):((1x.{toVec2Type x}) b):*
=3b:Raw.(1d.{get 0 d}):(0d:Vec2.Int:*) ((1x.{toVec2 x}) b):((1x.{toVec2Type x}) b):*
=3b:Raw.((1d.{get 0 d}) ((1x.{toVec2 x}) b)):((0d:Vec2.Int:*) ((1x.{toVec2 x}) b):((1x.{toVec2Type x}) b):*)
=3b:Raw.((1d.{get 0 d}) ((1x.{toVec2 x}) b)):(let 1D=(((1x.{toVec2Type x}) b):*)==Vec2:* in Int:*)
=3b:Raw.((1d.{get 0 d}) ((1x.{toVec2 x}) b)):(let 1D=(((1x.{toVec2Type x}) b)==Vec2):*==* in Int:*)
=3b:Raw.((1d.{get 0 d}) ((1x.{toVec2 x}) b)):(let 1D=(((1x.{toVec2Type x}) b)==Vec2):* in Int:*)
=3b:Raw.((1d.{get 0 d}) ((1x.{toVec2 x}) b)):((1D.Int) ((1x.{toVec2Type x}) b)==Vec2):(let 0D=* in *)
=3b:Raw.((1d.{get 0 d}) ((1x.{toVec2 x}) b)):((1D.Int) ((1x.{toVec2Type x}) b)==Vec2):*
=(1b.((1d.{get 0 d}) ((1x.{toVec2 x}) b))):(1b.((1D.Int) ((1x.{toVec2Type x}) b)==Vec2)):(0b:Raw.*)

parseAndFirst '[1,2]':Raw
=(1b.((1d.{get 0 d}) ((1x.{toVec2 x}) b))):(1b.((1D.Int) ((1x.{toVec2Type x}) b)==Vec2)):(0b:Raw.*) '[1,2]':Raw

\x.x:\x.2x:(_:Nat.*) {+ 1 2}:Nat
=(\x.x:2x)

(\x. x:x):(_:Nat:*.*) 3:Nat:*
=((\x.x:x) 3):((_:Nat:*.*) 3:Nat:*)
=((\x.x:x) 3):*
=3:3:*

(\a:3:*.a)
=(\a.a):(_:3:*.3:*)

(\a.a):(_:3:*.3:*) ((\x.x:x) 3):*
=t:((_:3:*.3:*) ((\x.x:x) 3):*)

id=\A:*.\x:A.x
=(_.\x.x):(\A:*.\x:A.A)
=(_.\x.x):(\A._.A):(\A:*.\x:A.*)
=(_.\x.x):(\A._.A):(\A:*.A->*)

id (\B:*.\x:B.B)
=let A=(\B:*.\x:B.B) in \x:A.x
=\x:(\B:*.\x:B.B). x

(\x:(\B:*.\x:B.B). x) (_.\y.y):(\A:*.\x:A.A)
=let x=(_.\y.y):(\A:*.\x:A.A)==(\B:*.\x:B.B) in x
typeof
=let X=(\A:*.\x:A.A)==(\B:*.\x:B.B) in X

TEST
\A:*.(\x:A.x) 3:3
=\A:*. let x=3:3==A in x
=(\A.(\x.x) 3):(\A:*. 3==A)
=(\A.(\x.x) 3):(\A. 3==A):(\_.*)
=
=(\A.(\x.x) 3):(\A:*.(\_:A.A) 3:3)
=(\A.(\x.x) 3):(\A.(\_.A) 3):(\A:*.(\_:A.*) 3:3)

q=\A:*.(\x:A.4:Nat) 3:Nat

q Nat:*
=(\A:*.(\x:A.4:Nat) 3:Nat) Nat:*
=let A=Nat:*==* in (\x:A.4:Nat) 3:Nat
=let A=Nat:* in (\x:A.4:Nat) 3:Nat
=(\x:Nat:*.4:Nat) 3:Nat
=let x=3:(Nat==Nat:*) in 4:Nat
=let x=3:Nat in 4:Nat
=4:Nat

t[q Nat:*]
=t[q] Nat:*
=(\A:*.(t[\x:A.4:Nat]) 3:Nat) Nat:*
=(\A:*.(\x:A.t[4:Nat]) 3:Nat) Nat:*
=(\A:*.(\x:A.Nat:*) 3:Nat) Nat:*

q
=\A:*. let x=3:Nat==A in 4:Nat
=(\A. (\x.4) 3):(\A:*. (\y:*.Nat) A==Nat)
=(\A. (\x.4) 3):(\A. (\y.Nat) A==Nat):(_:*. (_:*.*) *)
=(\A. (\x.4) 3):(\A. (\y.Nat) A==Nat):(_:*. *)
=(\A. (\x.4) 3):(\A. (\y.Nat) A==Nat):(_:*. *)

\A:*.\x:A.x
=(\A.\x.x):(\A:*.\x:A.A)
=(\A.\x.x):(\A.\x.A):()

(\A:*.\x:A.4:Nat) Nat:* 3:Nat
=(let A=Nat:*==* in \x:A.4:Nat) 3:Nat
=(let A=Nat:* in \x:A.4:Nat) 3:Nat
=(\x:Nat:*.4:Nat) 3:Nat
=let x=3:(Nat==Nat:*) in 4:Nat
=let x=3:Nat in 4:Nat
=4:Nat

(\A:*.\x:A.4:Nat) Nat:* 3:Nat
=((\A.\x.4) Nat 3):((\A:*.\_:A.Nat) Nat:* 3:Nat)
=((\A.\x.4) Nat 3):((let A=Nat:*==* in \_:A.Nat) 3:Nat)
=((\A.\x.4) Nat 3):((let A=Nat:* in \_:A.Nat) 3:Nat)
=((\A.\x.4) Nat 3):((\_:Nat.Nat) 3:Nat)
=((\A.\x.4) Nat 3):(let _=Nat==Nat in Nat)


\x:Nat.x:x:*
=(\x.x:x):(:Nat.*)

(\x:Nat.x:x:*) 3:Nat
=let x=3:Nat==Nat in x:x:*
=let x=3:Nat in x:x:*
=3:3:*

(\x.x:x):(:Nat.*) 3:Nat
=((\x.x:x) 3):((:Nat.*) Nat)
=((\x.x:x) 3):(Nat==Nat;*)
=((\x.x:x) 3):(Nat;*)
=((\x.x:x) 3):*
=(3:3):*
=3:3:*

(\a:3:*.a) ((\x.x:x) 3):*
=let a=(((\x.x:x) 3):*)==(_:3:*) in a
=let a=(((\x.x:x) 3)==_:3):*

\x:Nat.x:x:*
=(\x.x):(\x.x):(:Nat.*)

(\x.x):(\x.x):(:Nat.*) 3:3:Nat
=((\x.x) 3):((\x.x) 3):(Nat==Nat;*)

(\a:3:*.a)
=(\a.a):(:3:*.3:*)
=(\a.a):(:3.3):(:*.*)

(\a.a):(:3.3):(:*.*) ((\x.x:x) 3):*

\A:*.\x:A.x
=(\A.\x.x):(:*.)

(_.\x.x):(\A.:A.A):(:*._.*) *:Nat:*
=((_.\x.x) *):((\A.:A.A) Nat):((:*._.*) *)
=((_.\x.x) *):((\A.:A.A) Nat):((\._.*) *=*)
=((_.\x.x) *):((\A.:A.A) Nat):((\._.*) *)
=((_.\x.x) *):((\A.:A.A) Nat):(_.*)
=((_.\x.x) *):(:Nat.Nat):(_.*)
=(\x.x):(:Nat.Nat):(_.*)
=(\x.x):(:Nat.Nat)

(\x.x):(:Nat.Nat) 3:Nat
=((\x.x) 3):((:Nat.Nat) Nat)
=((\x.x) 3):((\.Nat) Nat==Nat)
=((\x.x) 3):((\.Nat) Nat)
=((\x.x) 3):Nat
=3:Nat

\x:Float. if x then 3:Nat else "dfd":String
=(\x.if x then 3 else "dfdf):(Float. Float==Bool;Nat==String)
=(\x.if x then 3 else "dfdf):(Float. error;Nat==String)
=(\x.if x then 3 else "dfdf):(Float. error)
=(\x.if x then 3 else "dfdf):error
=error

https://www.cs.cmu.edu/~janh/courses/ra19/assets/pdf/lect04.pdf

Linear type
\f:u->u->t.\x:u.\y:u. ((f x) y)
=(\f.\x.\y. (f x) y):(u->u->t.u.u. (u->u->t u) u)

x=10; while x > 0: print(x); x = x - 1


id=(*:\A).\x:A.x
=(*:\A).(\x.x):(A.let x=A in x)
=(*.(\x.x)):(\A.(A.let x=A in x))

id *:Nat 3:Nat
=(*.(\x.x)):(\A.(A.let x=A in x)) *:Nat 3:Nat
=((*.(\x.x)) * 3):(\A.(A.let x=A in x) Nat Nat)
=((*.(\x.x)) * 3):((Nat.let x=Nat in x) Nat)
=((*.(\x.x)) * 3):((\.let x=Nat in x) Nat==Nat)
=((*.(\x.x)) * 3):((\.let x=Nat in x) Nat)
=((*.(\x.x)) * 3):(let x=Nat in x)
=((*.(\x.x)) * 3):Nat
=((\.(\x.x)) *==* 3):Nat
=((\x.x) 3):Nat
=3:Nat

x|\:Nat.x
=(\x.x):(Nat.(\x.x) Nat)
=(\x.x):(Nat.Nat)

id=A|*:\.x|\:A.x
=A|*:\.(\x.x):(A.(\x.x) A)
=A|*:\.(\x.x):(A.A)
=(*.(\A.(\x.x)) *):(\A.(A.A))
=(*.(\x.x)):(\A.(A.A))

idNat=id *:Nat
=(*.(\x.x)):(\A.(A.A)) *:Nat
=((*.(\x.x)) *):((\A.(A.A)) Nat)
=((*.(\x.x)) *):(Nat.Nat)
=((\.(\x.x)) *=*):(Nat.Nat)
=(\x.x):(Nat.Nat)

idNat 3:Nat
=(\x.x):(Nat.Nat) 3:Nat
=((\x.x) 3):((Nat.Nat) Nat)
=((\x.x) 3):((\.Nat) Nat=Nat)
=((\x.x) 3):((\.Nat) Nat)
=((\x.x) 3):Nat
=3:Nat


q=x|\:(\:Nat).x:x
=(x|\.x):(x|(\:Nat).x)
=(\x.x):((x|\.x):(x|Nat.x))
=(\x.x):((\x.x):(Nat.(\x.x) Nat))
=(\x.x):((\x.x):(Nat.Nat))

(\x.x):((\x.x):(Nat.Nat)) 3:(3,Nat)
=((\x.x) 3):(((\x.x):(Nat.Nat)) (3,Nat))
=((\x.x) 3):(((\x.x) 3):((Nat.Nat) Nat))
=((\x.x) 3):(((\x.x) 3):((\.Nat) Nat=Nat))
=((\x.x) 3):(((\x.x) 3):((\.Nat) Nat))
=((\x.x) 3):(3:Nat)
=3:(3:Nat)

OpenFile|ClosedFile
open:String->[OpenFile]
read:[OpenFile]->String
close:[OpenFile]=>\x.x[0]:=ClosedFile;x


f:=open('a.txt')
close(f)
read(f)

f:=open:String->[OpenFile] 'a.txt':String
(close:[OpenFile]=>\x.x[0]:=ClosedFile;x) f
read:[OpenFile]->String f

(f:=open 'a.txt'):(f:=String->[OpenFile] String)
(close f):(([OpenFile]=>\x.x[0]:=ClosedFile;x) f)
(read f):([OpenFile]->String f)

f:=open 'a.txt'
close f
read f
:
f:=String->[OpenFile] String
([OpenFile]=>\x.x[0]:=ClosedFile;x) f
[OpenFile]->String f

{f:[OpenFile]}([OpenFile]=>\x.x[0]:=ClosedFile;x) f;[OpenFile]->String f
{f:[OpenFile]}[OpenFile]=f;((\x.x[0]:=ClosedFile;x) f);[OpenFile]->String f
{f:[OpenFile]}((\x.x[0]:=ClosedFile;x) f);[OpenFile]->String f
{f:[ClosedFile]}[OpenFile]->String f
{f:[ClosedFile]}[OpenFile]=[ClosedFile];String
{f:[ClosedFile]}not equal error;String

-------------------------------------------------------------------------------

all built-ins are inside braces. eg: {a+b}

# Symple type

plus=(\x!-.\y!-.{x+y}):Int->Int->Int

inc=\a!-:Int.plus a 1:Int
=\a!-:Int.(plus_L a 1):(plus_H a Int)
=(\a!-.plus_L a 1):(\a!Int.plus_H a Int)
=(\a!-.plus_L a 1):(\a!Int.plus_H a Int)
=(\a!-.plus_L a 1):Int->(plus_H Int Int)
=(\a!-.plus_L a 1):Int->(Int->Int->Int Int Int)
=(\a!-.plus_L a 1):Int->(-->Int->Int Int=Int Int)
=(\a!-.plus_L a 1):Int->(-->Int->Int Int Int)
=(\a!-.plus_L a 1):Int->(Int->Int Int)
=(\a!-.plus_L a 1):Int->(-->Int Int=Int)
=(\a!-.plus_L a 1):Int->(-->Int Int)
=(\a!-.plus_L a 1):Int->Int

# Polymorphic type

id=\A!-:-.\a!-:A.a
=\A!-:-.(\a!-.a):(\a!A.a)
=(\A!-.\a!-.a):(\A!-.\a!A.a)

idInt=id -:Int
=(\A!-.\a!-.a):(\A!-.\a!A.a) -:Int
=((\A!-.\a!-.a) -):((\A!-.\a!A.a) Int)
=((\A!-.\a!-.a) -):(\a!Int.a)
=((\A!-.\a!-.a) -):Int->Int
=(\a!-.a):Int->Int

idInt 3:Int
=(\a!-.a):Int->Int 3:Int
=((\a!-.a) 3):(Int->Int Int)
=((\a!-.a) 3):(-->Int Int=Int)
=((\a!-.a) 3):(-->Int Int)
=((\a!-.a) 3):Int
=3:Int

# Dependent type

List=\n!-:Int.{'List'+n}:String
=(\n!-.{'List'+n}):(\n!Int.String)
=(\n!-.{'List'+n}):Int->String

nil='[]':'List0'
cons=\n!-:(-:Int).\a!-:(List n).\b!-:(Float:*).{append a b}:(List (inc n))
=(\n!-.\a!-.\b!-.{append a b}):(\n!-:Int.\a!(List n).\b!(Float:-).(List (inc n)))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(\n!Int.\a!(List_H n).\b!*.(List_H (inc_H n))))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->\a!(List_H Int).\b!*.(List_H (inc_H Int))))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->\a!(Int->String Int).\b!*.(List_H (inc_H Int))))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->\a!(-->String Int=Int).\b!*.(List_H (inc_H Int))))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->\a!(-->String Int).\b!*.(List_H (inc_H Int))))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->\a!String.\b!*.(List_H (inc_H Int))))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->String->\b!*.(Int->String (Int->Int Int))))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->String->\b!*.(Int->String (Int->Int Int))))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->String->*->(Int->String (Int->Int Int))))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->String->*->(Int->String Int)))
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->String->*->String))


cons0=cons -:(0:Int)
=(\n!-.\a!-.\b!-.{append a b}):((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))):(Int->String->*->String)) -:(0:Int)
=((\n!-.\a!-.\b!-.{append a b}) -):(((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))) 0):((Int->String->*->String) Int))
=((\n!-.\a!-.\b!-.{append a b}) -):(((\n!-.\a!(List_L n).\b!Float.(List_L (inc_L n))) 0):(String->*->String))
=((\n!-.\a!-.\b!-.{append a b}) -):((\a!(List_L 0).\b!Float.(List_L (inc_L 0))):(String->*->String))
=((\n!-.\a!-.\b!-.{append a b}) -):((\a!'List0'.\b!Float.(List_L (inc_L 0))):(String->*->String))
=((\n!-.\a!-.\b!-.{append a b}) -):(('List0'->\b!Float.(List_L (inc_L 0))):(String->*->String))
=((\n!-.\a!-.\b!-.{append a b}) -):(('List0'->Float->(List_L (inc_L 0))):(String->*->String))
=((\n!-.\a!-.\b!-.{append a b}) -):(('List0'->Float->(List_L 1)):(String->*->String))
=((\n!-.\a!-.\b!-.{append a b}) -):(('List0'->Float->'List1'):(String->*->String))

# Substructural type

newHandler=\z!-:Void."new Status(Open)":Handler
=(\z!-."new Status(Open)"):(\z!Void.Handler)
=(\z!-."new Status(Open)"):Void->((\z!-.Handler) Void)
=(\z!-."new Status(Open)"):Void->Handler

closeHandler=\h!-:Handler."h.setClosed()":Void
=(\h!-."h.setClosed()"):(\h!Handler.Void)
=(\h!-."h.setClosed()"):Handler->((\h!-.Void) Handler)
=(\h!-."h.setClosed()"):Handler->Void

checkHandlerOpen=\h!-:Handler."h.checkOpened()":Void
=(\h!-."h.checkOpened()"):(\h!Handler.Void)
=(\h!-."h.checkOpened()"):Handler->((\h!-.Void) Handler)
=(\h!-."h.checkOpened()"):Handler->Void

open=\f!-:String."open f":{newHandler()}
=(\f!-."open f"):(\f!String.{newHandler()})
=(\f!-."open f"):String->((\f!-.{newHandler()}) String)
=(\f!-."open f"):String->{newHandler()}

close=\h!-:{-:Handler}."close h":{closeHandler} h
=(\h!-."close h"):(\h!{-:Handler}.{closeHandler} h)
=(\h!-."close h"):{\h!-:Handler.closeHandler h}

read=\h!-:{-:Handler}."read f":{checkHandlerOpen} h;String
=(\h!-."read f"):(\h!{-:Handler}.{checkHandlerOpen} h;String)
=(\h!-."read f"):{\h!-:Handler.checkHandlerOpen h;String:-}

readFileContent=\f!-:String:h=open f;close h;read h
=(\f!-.open_L f;close_L h;read_L h):(\f!String.h=open_H f;close_H h;read_H h)


(\f!String.h=open_H f;close_H h;read_H h)
=String->((\f!-.h=open_H f;close_H h;read_H h) String)
=String->(h=open_H String;close_H h;read_H h)
=String->(h=String->{newHandler()} String;close_H h;read_H h)
=String->(h={newHandler()};close_H h;read_H h)


-------------------------------------------------------------------------------

all built-ins are inside double quotes. eg: "a+b"

# Simple type

plus=(\x!-.\!-."x+y"):Int->Int->Int

inc=plus 1:Int
=(\x!-.\y!-."x+y"):Int->Int->Int 1:Int
=((\x!-.\y!-."x+y") 1):(Int->Int->Int Int)
=((\x!-.\y!-."x+y") 1):Int->Int
=(\t!-."1+y"):Int->Int

inc 2:Int
=(\t!-."1+y"):Int->Int 2:Int
=((\t!-."1+y") 2):(Int->Int Int)
="1+2":Int
="3":Int

# Polymorphic type

id=\A!-:-.\a!-:A.a
=(\A!-.\a!-.a):(\A!-.\a!A.a)

idInt=(\A!-.\a!-.a):(\A!-.\a!A.a) -:Int
=((\A!-.\a!-.a) -):((\A!-.\a!A.a) Int)
=((\A!-.\a!-.a) -):(\a!Int.a)
=((\A!-.\a!-.a) -):Int->Int
=(\a!-.a):Int->Int

idInt 3:Int
=(\a!-.a):Int->Int 3:Int
=((\a!-.a) 3):(Int->Int Int)
=((\a!-.a) 3):Int
=3:Int

# Dependent type

List=\n!-:Int."'List'+n":String
=(\n!-."'List'+n"):(\n!Int.String)
=(\n!-."'List'+n"):Int->String

nil="[]":"List0"

cons0=\a!-:List0.\b!-:Float."append a b":List1
=(\a!-.\b!-."append a b"):(\a!List0.\b!Float.List1)
=(\a!-.\b!-."append a b"):List0->Float->List1
cons1=\a!-:List1.\b!-:Float."append a b":List2
=(\a!-.\b!-."append a b"):List1->Float->List2

cons=\n!-:(-:Int).(\a!-.\b!-."append a b"):(List n)->Float:*->(List (inc n))
=(\n!-.\a!-.\b!-."append a b"):(\n!-:Int.(List n)->Float:*->(List (inc n)))

# Substructural type

void="none":Void
newStatus=(\z!-."new Status(Open)"):Void->Status
closeStatus=(h!-."h.setClosed()"):Status->Void
checkStatusOpen=(\h!-."h.checkOpened()"):Status->Open

openFile=(\f!-."open f"):String->Handler
closeFile=(\f!-."close f"):Handler->Void
readFile=(\f!-."read f"):Handler->String

open=openFile:newStatus
close=closeFile:closeStatus
read=readFile:checkStatusOpen

readFileContent=\f!-:String. @(h=open f:void;close h;read h)
=\f!-:String. @((h=openFile f;closeFile h;readFile h):(h=open void;close h;read h))

# let binding syntax sugar

let a=v in b
(\a!-:-.b) v

inc=(\t!-."1+y"):Int->Int

let a=3:Int in (inc a)
(let a=3 in inc_L a):(let a=Int in inc_H a)

inc_H Int
=Int->Int Int
=Int

(\a!-:-.inc a) 3:Int
(\a!-.(\t!-."1+y") a):(\a!-.Int->Int a) 3:Int

(\a!-.Int->Int a) Int
=Int->Int Int
=Int
